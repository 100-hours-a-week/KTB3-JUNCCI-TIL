# Frontend Fundamentals - 예측가능성
이번 글은 [**Frontend Fundamentals**](https://frontend-fundamentals.com/code-quality/)의 **좋은 코드의 기준 알아보기** 섹션을 리뷰한 글이에요.  
이번에는 **‘예측 가능성(Predictability)’** 를 중심으로 정리해봤습니다 :)

---

## 목차 

### **A.이름 겹치지 않게 관리하기**
### **B.같은 종류의 함수는 반환 타입 통일하기**
### **C.숨은 로직 드러내기**


---

## <mark> 🅐 이름 겹치지 않게 관리하기 — 함수 이름이 동작을 속이지 않게  </mark>

### 🚫 예측 가능성이 떨어지는 코드 🚫

```ts
import { http as httpLibrary } from "@some-library/http";

export const http = {
  async get(url: string) {
    const token = await fetchToken();
    return httpLibrary.get(url, {
      headers: { Authorization: `Bearer ${token}` }
    });
  }
};
```

이 코드는 기능적으로는 문제없지만,
`http.get()`이라는 이름만 보면 단순한 HTTP 요청처럼 보여요.
하지만 실제로는 **토큰을 가져와 헤더에 추가하는 숨은 인증 로직**이 들어있어요.

이런 작은 차이가 코드의 **예측 가능성**을 낮추고, 협업 시 혼란을 일으킬 수 있습니다.

---

### ✅ 개선된 코드 ✅

```ts
// 외부 HTTP 라이브러리의 http 객체를 httpLibrary라는 이름으로 불러옴
import { http as httpLibrary } from "@some-library/http";

// 내 프로젝트에서도 같은 이름의 http 객체를 새로 정의
export const httpService = {
  async getWithAuth(url: string) {
    const token = await fetchToken();
    return httpLibrary.get(url, {
      headers: { Authorization: `Bearer ${token}` }
    });
  }
};
```

`httpService.getWithAuth()`처럼 함수 이름만 봐도
“이건 인증된 요청을 보낸다”는 걸 알 수 있게 했어요.

이렇게 **의도를 드러내는 네이밍**은 예측 가능성을 높이고,
오해를 줄여줍니다.

---

### 📌 용어 정리 1 — HTTP 라이브러리란?

HTTP 라이브러리는 **웹 서버와 데이터를 주고받기 위한 도구**예요.
즉, 브라우저나 서버에서 **API 요청(요청 보내기)** 과 **응답 처리(결과 받기)**를 쉽게 해주는 코드 모음입니다.

예시:

* `fetch()` → 브라우저에 내장된 기본 HTTP 함수
* `axios.get("/users")` → 더 편리하게 요청을 보낼 수 있게 도와주는 외부 라이브러리

이런 라이브러리를 사용하면 직접 `XMLHttpRequest`를 다루지 않아도 되고,
요청 헤더 설정, 에러 처리, 응답 파싱 등을 간단하게 처리할 수 있습니다.

---

##  <mark> 🅑 같은 종류의 함수는 반환 타입 통일하기 — 일관성 유지하기 </mark> 

### 🚫 문제 상황 🚫

비슷한 역할의 함수나 Hook이 서로 **다른 반환 타입**을 가지면,
코드를 읽는 사람은 “이건 객체였나? 데이터였나?”를 계속 확인해야 합니다.

```ts
function useUser() {
  const query = useQuery({ queryKey: ["user"], queryFn: fetchUser });
  return query; // Query 객체 반환
}

function useServerTime() {
  const query = useQuery({ queryKey: ["serverTime"], queryFn: fetchServerTime });
  return query.data; // 데이터만 반환
}
```

이렇게 반환 타입이 다르면 예측하기 어려워져요.
같은 패턴의 함수는 **같은 규칙**을 따르는 게 중요합니다.

---

### 📌 용어 정리 2 — Query 객체 반환 vs 데이터 반환

* **Query 객체 반환** → `data`, `isLoading`, `error` 같은 상태 정보를 모두 담은 **전체 객체**를 반환
* **데이터만 반환** → 그 중 **`data` 값 하나만 꺼내서 반환**

| 구분  | Query 객체 반환                                | 데이터만 반환              |
| --- | ------------------------------------------ | -------------------- |
| 반환값 | `{ data, isLoading, error, refetch, ... }` | `data` (실제 값만)       |
| 특징  | API 결과 + 상태 관리 포함                          | 단순히 데이터만 제공          |
| 장점  | 로딩, 에러, 재요청 등 제어 가능                        | 코드가 간단               |
| 단점  | 구조가 다소 복잡                                  | 상태 정보 손실             |
| 예시  | `return query;`                            | `return query.data;` |

> 즉, Query 객체 반환은 **“상태를 함께 다루는 방식”**,
> 데이터만 반환은 **“값만 간단히 가져오는 방식”**이다.

---

### ✅ 개선된 코드 ✅

```ts
function useServerTime() {
  const query = useQuery({ queryKey: ["serverTime"], queryFn: fetchServerTime });
  return query; // 통일된 반환 타입
}
```

이처럼 팀에서 사용하는 Hook들이 같은 구조로 작성되어 있다면,
“이건 항상 Query 객체를 반환하겠구나” 하고 예측할 수 있어요.

---

### 💡 또 다른 예시 💡

```ts
function checkIsNameValid(name: string) {
  return { ok: name.length > 0 && name.length < 20 };
}

function checkIsAgeValid(age: number) {
  return { ok: age >= 18 && age <= 99 };
}
```

두 함수가 동일한 `{ ok: boolean }` 형태로 결과를 반환하니,
코드를 읽는 사람은 조건 분기 시 혼란을 겪지 않아요.

---

## <mark> 🅒 숨은 로직 드러내기 — 예상 밖의 행동을 피하라 </mark>

### 🚫 문제 상황 🚫

```ts
async function fetchBalance(): Promise<number> {
  const balance = await http.get<number>("...");
  logging.log("balance_fetched");
  return balance;
}
```

이 함수는 이름과 반환 타입만 봤을 땐 단순히 잔액을 가져오는 것처럼 보이지만,
사실 내부에서 **로그를 남기는 부수 효과(side effect)**가 숨어 있어요.

이런 숨은 로직은 예측 불가능한 코드를 만들고, 디버깅을 어렵게 만듭니다.

---

### ✅ 개선된 코드 ✅

```ts
async function fetchBalance(): Promise<number> {
  return await http.get<number>("...");
}
```

로깅은 함수 밖으로 분리해 명시적으로 호출합니다.

```tsx
<Button
  onClick={async () => {
    const balance = await fetchBalance();
    logging.log("balance_fetched");
  }}
>
  계좌 잔액 갱신하기
</Button>
```

이제 코드만 봐도 어떤 동작이 일어나는지 명확하게 알 수 있어요.
**로직이 드러나면, 코드의 예측 가능성도 자연스럽게 높아집니다.**

---

## ✍️ 마무리 — 예측 가능한 코드가 협업을 바꾼다

가독성이 “얼마나 쉽게 읽히는가”라면,
예측 가능성은 “읽은 뒤에 얼마나 신뢰할 수 있는가”이다.

같은 코드라도 **이름이 동작을 속이지 않고**,
**함수의 형태가 일관되며**, **숨은 로직이 없는 코드**는
협업 시 오해를 줄이고, 디버깅을 훨씬 쉽게 만든다.

앞으로는 기능 구현뿐 아니라,

> “이 코드가 다른 사람에게 얼마나 예측 가능한가?”
> 를 한 번 더 고민하며 작성하려 한다.

코드는 결국 **함께 읽는 문서**이니까.

---

원하신다면 이 마크다운 버전을 블로그용 포맷(썸네일 문구, 태그, 구름EDU 스타일 메타 포함)으로도 변환해드릴 수 있어요. 그렇게 해드릴까요?
