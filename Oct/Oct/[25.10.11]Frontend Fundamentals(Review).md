# Frontend Fundamentals - 결합도
이번 글은 [**Frontend Fundamentals**](https://frontend-fundamentals.com/code-quality/)의 **좋은 코드의 기준 알아보기** 섹션을 리뷰한 글이에요.  
이번에는 **‘결합도(Coupling)’** 를 중심으로 정리해봤습니다 :)

---
## 목차
### **A.책임을 하나씩 관리하기**
### **B.중복 코드 허용하기**
### **C.Props Drilling 지우기**

---

## ⁉️ 결합도란?

> 결합도(Coupling)는 서로 다른 모듈(컴포넌트, 함수, 훅 등)이
> **얼마나 강하게 연결되어 있는지를 나타내는 지표**예요.
>
> 결합도가 높을수록 코드 간의 영향 범위가 넓어지고,
> 한 부분을 수정할 때 다른 부분까지 함께 수정해야 하는 상황이 자주 발생합니다.
>
> 반대로 결합도가 낮으면, 기능을 독립적으로 수정하고 테스트할 수 있어
> 유지보수가 쉬워집니다.

---

## 🅐 책임을 하나씩 관리하기 — 불필요한 결합 줄이기

### 🚫 결합도가 높은 코드

```ts
import moment, { Moment } from "moment";
import { useMemo } from "react";
import {
  ArrayParam,
  DateParam,
  NumberParam,
  useQueryParams
} from "use-query-params";

export function usePageState() {
  const [query, setQuery] = useQueryParams({
    cardId: NumberParam,
    statementId: NumberParam,
    dateFrom: DateParam,
    dateTo: DateParam,
    statusList: ArrayParam
  });

  return useMemo(
    () => ({
      values: {
        cardId: query.cardId ?? undefined,
        statementId: query.statementId ?? undefined,
        dateFrom:
          query.dateFrom == null ? moment().subtract(3, "month") : moment(query.dateFrom),
        dateTo: query.dateTo == null ? moment() : moment(query.dateTo),
        statusList: query.statusList as StatementStatusType[] | undefined
      },
      controls: {
        setCardId: (cardId: number) => setQuery({ cardId }, "replaceIn"),
        setStatementId: (statementId: number) =>
          setQuery({ statementId }, "replaceIn"),
        setDateFrom: (date?: Moment) =>
          setQuery({ dateFrom: date?.toDate() }, "replaceIn"),
        setDateTo: (date?: Moment) =>
          setQuery({ dateTo: date?.toDate() }, "replaceIn"),
        setStatusList: (statusList?: StatementStatusType[]) =>
          setQuery({ statusList }, "replaceIn")
      }
    }),
    [query, setQuery]
  );
}
```

이 `usePageState()` 훅은
**페이지 전체의 쿼리 파라미터를 한 번에 관리**하고 있어요.

겉보기엔 편해 보이지만, “카드 ID”, “날짜”, “상태” 등 **서로 다른 책임**이 한데 섞여 있습니다.
결과적으로 페이지의 여러 컴포넌트가 이 훅에 강하게 의존하게 되고,
하나의 필드 로직을 수정해도 전체가 흔들릴 수 있어요.

---

### ✅ 개선된 코드 — 책임 분리로 결합도 낮추기

```ts
import { useQueryParam } from "use-query-params";

export function useCardIdQueryParam() {
  const [cardId, setCardId] = useQueryParam("cardId", NumberParam);
  return [cardId ?? undefined, (v: number) => setCardId(v, "replaceIn")] as const;
}
```

쿼리 파라미터별로 **작은 단위의 Hook**으로 분리하면,
수정 시 영향 범위가 명확해집니다.
예를 들어 `cardId` 관련 변경이 `date`나 `status` 로직에 영향을 주지 않아요.

> ✅ 한 Hook이 하나의 책임만 가진다면,
> 수정·테스트·재사용이 모두 쉬워집니다.

---

## 🅑 중복 코드 허용하기 — 잘못된 공통화가 만드는 결합 피하기

### 🚫 결합도가 높은 코드

```ts
export const useOpenMaintenanceBottomSheet = () => {
  const maintenanceBottomSheet = useMaintenanceBottomSheet();
  const logger = useLogger();

  return async (info: TelecomMaintenanceInfo) => {
    logger.log("점검 바텀시트 열림");
    const result = await maintenanceBottomSheet.open(info);
    if (result) logger.log("점검 바텀시트 알림받기 클릭");
    closeView();
  };
};
```

이 Hook은 여러 페이지에서 공통적으로 쓰이기 때문에
“공통화”된 로직처럼 보이지만, 실제로는 **결합된 위험한 구조**입니다.

* 페이지마다 로그 메시지가 다르다면?
* 어떤 페이지에서는 닫기 동작이 필요 없을 수도 있다면?
* 다른 화면에서는 바텀시트 디자인이 달라진다면?

이 경우 Hook 내부를 수정해야 하고,
이 Hook을 사용하는 **모든 페이지가 테스트 대상**이 되어버립니다.

---

### ✅ 개선된 방향 — 중복을 허용하고 유연성 확보하기

비슷해 보이는 로직이라도,
**앞으로 다르게 진화할 가능성**이 있다면
공통화하지 말고 **중복을 허용**하는 것이 더 낫습니다.

```ts
// PageA
export function useOpenMaintenanceBottomSheetA() {
  const sheet = useMaintenanceBottomSheet();
  const logger = useLogger();

  return async (info: TelecomMaintenanceInfo) => {
    logger.log("A 페이지 점검 안내");
    await sheet.open(info);
  };
}
```

```ts
// PageB
export function useOpenMaintenanceBottomSheetB() {
  const sheet = useMaintenanceBottomSheet();
  const logger = useLogger();

  return async (info: TelecomMaintenanceInfo) => {
    logger.log("B 페이지 점검 안내");
    const result = await sheet.open(info);
    if (result) logger.log("알림받기 클릭");
  };
}
```

두 페이지가 일시적으로 비슷하더라도,
서로 다른 맥락을 갖는다면 **강제 공통화는 결합도를 높입니다.**

> 💡 중복을 허용하는 용기 =
> “독립적으로 진화할 수 있는 코드”를 위한 투자입니다.

---

## 🅒 Props Drilling 지우기 — 부모-자식 간 결합 줄이기

### 🚫 결합도가 높은 구조

```tsx
function ItemEditModal({ open, items, recommendedItems, onConfirm, onClose }) {
  const [keyword, setKeyword] = useState("");

  return (
    <Modal open={open} onClose={onClose}>
      <ItemEditBody
        items={items}
        keyword={keyword}
        onKeywordChange={setKeyword}
        recommendedItems={recommendedItems}
        onConfirm={onConfirm}
        onClose={onClose}
      />
    </Modal>
  );
}
```

이 구조는 부모(`ItemEditModal`) → 자식(`ItemEditBody`) → 손자(`ItemEditList`)로
같은 Props를 계속 전달하고 있습니다.
Prop이 바뀌면 **연쇄적으로 모든 컴포넌트를 수정**해야 하죠.
이게 바로 전형적인 **Props Drilling으로 인한 결합**입니다.

---

### ✅ 개선 ① — Composition 패턴으로 결합 완화

```tsx
function ItemEditModal({ open, items, recommendedItems, onConfirm, onClose }) {
  const [keyword, setKeyword] = useState("");

  return (
    <Modal open={open} onClose={onClose}>
      <ItemEditBody keyword={keyword} onKeywordChange={setKeyword} onClose={onClose}>
        <ItemEditList
          keyword={keyword}
          items={items}
          recommendedItems={recommendedItems}
          onConfirm={onConfirm}
        />
      </ItemEditBody>
    </Modal>
  );
}
```

`children`을 사용하면 데이터 흐름을 단순화하고,
부모가 자식 구조를 유연하게 조립할 수 있습니다.
이제 중간 컴포넌트(`ItemEditBody`)가 불필요한 props를 전달하지 않아도 되죠.

---

### ✅ 개선 ② — Context API로 깊은 결합 해소

```tsx
const ItemEditModalContext = createContext();

export function ItemEditModal({ open, onConfirm, onClose }) {
  const [keyword, setKeyword] = useState("");
  const contextValue = { keyword, setKeyword, onConfirm };

  return (
    <ItemEditModalContext.Provider value={contextValue}>
      <Modal open={open} onClose={onClose}>
        <ItemEditBody />
        <ItemEditList />
      </Modal>
    </ItemEditModalContext.Provider>
  );
}

function ItemEditList() {
  const { keyword, onConfirm } = useContext(ItemEditModalContext);
  // ...
}
```

이제 `keyword`, `onConfirm`을 Props로 전달하지 않아도
모든 하위 컴포넌트가 Context로 접근할 수 있습니다.
Props Drilling로 인한 결합을 완전히 끊어낼 수 있죠.

> ⚠️ 단, Context는 “최후의 수단”입니다.
> 단순한 구조라면 Composition으로 충분히 해결할 수 있습니다.

---

## 📌 용어 정리

| 용어                | 의미                         | 좋은 상태       |
| ----------------- | -------------------------- | ----------- |
| **응집도(Cohesion)** | 관련 기능이 얼마나 한곳에 잘 모여 있는가    | **높을수록 좋음** |
| **결합도(Coupling)** | 서로 다른 모듈이 얼마나 강하게 연결되어 있는가 | **낮을수록 좋음** |

---

## ✍️ 머리가 띵 어지러워~

저는 개인적으로 **결합도 파트 중 ‘중복 코드 허용하기’에서 머리에 띵 맞은 기분**이었습니다.

그동안 개발하면서 “중복은 나쁜 것”이라고만 배워왔거든요.
그래서 비슷한 코드가 보이면 무의식적으로 공통화부터 시도했어요.
“이거 Hook으로 빼자”, “공통 컴포넌트로 만들자” 같은 생각이 자연스러웠죠.

하지만 글에서 말하듯, **“비슷해 보여도 다른 맥락”**이라면 그건 공통화의 대상이 아니라
**독립적인 진화의 여지가 있는 코드**였다는 걸 깨달았습니다.


