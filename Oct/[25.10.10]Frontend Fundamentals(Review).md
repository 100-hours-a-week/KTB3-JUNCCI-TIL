# Frontend Fundamentals - 응집도
이번 글은 [**Frontend Fundamentals**](https://frontend-fundamentals.com/code-quality/)의 **좋은 코드의 기준 알아보기** 섹션을 리뷰한 글이에요.  
이번에는 **‘응집도(Cohesion)’** 를 중심으로 정리해봤습니다 :)

---
# 목차 
### **A.함께 수정되는 파일을 같은 디렉토리에 두기**
### **B.매직 넘버 없애기**
### **C.폼의 응집도 생각하기**

---

## 🅐 함께 수정되는 파일을 같은 디렉토리에 두기 — 코드의 응집도 높이기

### 🚫 응집도가 낮은 구조

```plaintext
└─ src
   ├─ components
   ├─ constants
   ├─ containers
   ├─ contexts
   ├─ remotes
   ├─ hooks
   ├─ utils
   └─ ...
```

이 구조는 언뜻 보기엔 깔끔하지만, 실제로 **어떤 파일이 어떤 기능과 함께 수정되는지** 파악하기 어렵습니다.
파일을 종류별로만 나누면 **의존 관계를 명확히 파악하기 힘들고**,
사용되지 않는 코드가 남거나, 삭제할 때 연관된 코드가 함께 제거되지 않는 문제가 생길 수 있어요.

시간이 지나 프로젝트가 커지면 `components/`나 `hooks/` 폴더 안에 수백 개의 파일이 쌓이게 되고,
파일 간 관계를 기억해야 하는 부담이 점점 커집니다.

---

### ✅ 개선된 구조

```plaintext
└─ src
   ├─ components
   ├─ hooks
   ├─ utils
   ├─ ...
   └─ domains
      ├─ Domain1
      │   ├─ components
      │   ├─ hooks
      │   ├─ utils
      │   └─ ...
      └─ Domain2
          ├─ components
          ├─ hooks
          ├─ utils
          └─ ...
```

함께 수정되는 파일을 같은 디렉토리(`Domain1`, `Domain2`)에 두면,
**의존 관계가 명확히 드러나고** 유지보수가 쉬워집니다.

```ts
// 🚫 잘못된 참조 예시
import { useFoo } from "../../../Domain2/hooks/useFoo";
```

위처럼 `Domain1` 코드에서 `Domain2` 파일을 참조하면 잘못된 의존을 한눈에 알 수 있어요.
또한 특정 기능이 필요 없을 때 **폴더 단위로 삭제**하면 관련된 코드가 한 번에 정리되어
“죽은 코드(dead code)”를 남기지 않을 수 있습니다.

---

### 📌 용어 정리 1 — 응집도(Cohesion)

> 하나의 모듈(또는 디렉토리) 안에 **서로 밀접하게 관련된 기능들이 얼마나 잘 모여 있는가**를 나타내는 지표예요.
> 응집도가 높을수록 코드의 변경 범위가 작아지고, 수정 시 안정성이 높아집니다.

---

## 🅑 매직 넘버 없애기 — 의미를 가진 상수로 표현하기

### 🚫 코드 냄새: 매직 넘버

```ts
async function onLikeClick() {
  await postLike(url);
  await delay(300);
  await refetchPostLike();
}
```

여기서 `300`은 “애니메이션 완료 대기 시간”을 의미하지만,
코드를 처음 읽는 사람은 그 숫자가 무엇을 뜻하는지 알기 어렵습니다.
만약 애니메이션이 변경되면 이 숫자도 함께 수정되어야 하는데,
이를 놓치면 **응집도가 깨지고 버그가 생길 수 있어요.**

---

### ✅ 개선된 코드

```ts
const ANIMATION_DELAY_MS = 300;

async function onLikeClick() {
  await postLike(url);
  await delay(ANIMATION_DELAY_MS);
  await refetchPostLike();
}
```

이제 숫자의 의미가 명확하게 드러납니다.
“애니메이션과 관련된 딜레이”라는 사실을 이름만으로 이해할 수 있어요.

---

### 📌 용어 정리 2 — 매직 넘버 (Magic Number)

> 코드 내에서 **의미가 설명되지 않은 숫자 상수**를 직접 사용하는 것을 말해요.
> 의미가 명확하지 않아 가독성을 떨어뜨리고, 수정 시 실수를 유발합니다.
> 반드시 이름이 있는 상수로 치환해 의도를 드러내세요.

💡 **TIP:**
상수를 한곳에 모아 관리하면, 프로젝트 전반의 유지보수가 훨씬 쉬워집니다.
예:

```plaintext
constants/animation.ts → export const ANIMATION_DELAY_MS = 300;
```

---

## 🅒 폼의 응집도 생각하기 — 함께 수정되어야 할 코드는 함께 있게

### 🚫 문제 상황

Form은 여러 필드가 상호작용하는 복잡한 구조를 가집니다.
필드별로 로직이 흩어지거나, 폼 전체가 뒤섞여 있으면 유지보수가 어려워집니다.

---

### ① 필드 단위 응집도 (Field-level Cohesion)

```tsx
import { useForm } from "react-hook-form";

export function Form() {
  const {
    register,
    formState: { errors },
    handleSubmit
  } = useForm({
    defaultValues: { name: "", email: "" }
  });

  const onSubmit = handleSubmit((data) => console.log(data));

  return (
    <form onSubmit={onSubmit}>
      <input
        {...register("name", {
          validate: (v) =>
            isEmptyStringOrNil(v) ? "이름을 입력해주세요." : ""
        })}
        placeholder="이름"
      />
      {errors.name && <p>{errors.name.message}</p>}

      <input
        {...register("email", {
          validate: (v) =>
            isEmptyStringOrNil(v)
              ? "이메일을 입력해주세요."
              : !/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(v)
              ? "유효한 이메일 주소를 입력해주세요."
              : ""
        })}
        placeholder="이메일"
      />
      {errors.email && <p>{errors.email.message}</p>}

      <button type="submit">제출</button>
    </form>
  );
}
```

📍 각 필드의 검증 로직이 독립적이라
필드 하나를 수정하거나 재사용하기 쉬워요.
**“이름” 필드만 수정해도 다른 부분엔 영향이 없죠.**

---

### ② 폼 전체 단위 응집도 (Form-level Cohesion)

```tsx
import * as z from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";

const schema = z.object({
  name: z.string().min(1, "이름을 입력해주세요."),
  email: z
    .string()
    .min(1, "이메일을 입력해주세요.")
    .email("유효한 이메일 주소를 입력해주세요.")
});

export function Form() {
  const {
    register,
    formState: { errors },
    handleSubmit
  } = useForm({
    defaultValues: { name: "", email: "" },
    resolver: zodResolver(schema)
  });

  const onSubmit = handleSubmit((data) => console.log(data));

  return (
    <form onSubmit={onSubmit}>
      <input {...register("name")} placeholder="이름" />
      {errors.name && <p>{errors.name.message}</p>}
      <input {...register("email")} placeholder="이메일" />
      {errors.email && <p>{errors.email.message}</p>}
      <button type="submit">제출</button>
    </form>
  );
}
```

📍 모든 검증 로직을 하나의 스키마(schema)로 관리하여
폼 전체의 흐름을 한눈에 볼 수 있어요.
단, 필드 간 결합도가 높아 **재사용성은 떨어질 수 있습니다.**

---

### 💡 필드 단위 vs 폼 전체 단위 응집도 선택 기준

| 기준        | 필드 단위 응집도        | 폼 전체 단위 응집도      |
| --------- | ---------------- | ---------------- |
| **검증 범위** | 독립적 (각 필드별)      | 중앙 집중식 (전체 폼)    |
| **재사용성**  | 높음               | 낮음               |
| **변경 단위** | 필드 단위            | 폼 단위             |
| **예시**    | 이메일 형식 검증, 추천 코드 | 결제 폼, 회원가입, 설문 폼 |
| **장점**    | 유지보수 쉬움, 재사용 용이  | 흐름 일관성, 복잡한 폼 대응 |
| **단점**    | 흐름 파악 어려움        | 재사용 어려움, 결합도 증가  |

---

### 📌 용어 정리 3 — 응집도와 결합도

> **응집도(cohesion)**: 관련된 기능이 얼마나 한곳에 잘 모여 있는지
> **결합도(coupling)**: 서로 다른 모듈이 얼마나 강하게 연결되어 있는지
>
> ✅ 좋은 코드의 원칙:
>
> * **응집도는 높을수록 좋고**,
> * **결합도는 낮을수록 좋다.**

---

## ✍️ 응집도(Coherence)에 대해 배우며

이번에 ‘응집도’라는 개념을 공부하면서 **“함께 바뀌는 코드는 함께 있어야 한다”**는 말을 다시 생각하게 됐다.
그동안 나는 파일을 역할별로 나누는 데 집중했지만, 정작 기능 단위로 함께 수정되는 코드들이 서로 멀리 떨어져 있는 경우가 많았다.
예를 들어, 특정 기능을 수정하려면 components/, hooks/, utils/를 오가며 여러 파일을 찾아야 했는데,
이게 바로 응집도가 낮은 구조라는 걸 깨달았다.

응집도를 높이면 코드가 단순히 “보기 좋은” 수준을 넘어, 변경하기 쉬운 코드가 된다는 점이 인상 깊었다.
함께 수정되는 파일을 한 디렉토리에 두면 삭제나 리팩터링 시 영향 범위를 명확히 알 수 있고,
코드 간의 관계도 자연스럽게 드러난다.
매직 넘버처럼 의미 없는 값이나 폼 검증 로직의 분리 등도 결국 “응집도를 높이는 일”이라는 걸 배웠다.

결국 응집도는 단순히 폴더 구조의 문제가 아니라,
“하나의 변화가 어디까지 퍼져야 하는가”를 줄이는 설계 감각이라고 느꼈다.
앞으로는 새로운 기능을 만들 때, 파일을 어디에 둘지보다
“이 코드가 함께 바뀔 대상은 무엇일까?”를 먼저 생각하는 습관을 들이고 싶다.
