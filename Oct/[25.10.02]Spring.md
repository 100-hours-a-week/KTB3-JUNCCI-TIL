# 📌 Spring 핵심 개념 정리 - AOP 정리

## <mark> 1. 정의  </mark>

**<mark> AOP (Aspect-Oriented Programming, 관점 지향 프로그래밍)</mark>**

→ 프로그램의 핵심 기능(Core Concern)과 부가 기능(Cross-Cutting Concern)을 분리하여, 횡단 관심사를 모듈화하는 프로그래밍 기법이다.

---

## <mark>2. 설명</mark>

일반적인 객체지향 프로그래밍(OOP)에서는 공통된 부가 기능(예: 로깅, 보안, 트랜잭션 처리)을 각 클래스나 메서드 안에 흩뿌려서 작성하기 쉽다. 이 경우 코드의 **중복**과 **유지보수 어려움**이 발생한다.

AOP는 이런 공통 관심사(Cross-Cutting Concern)를 독립된 모듈(Aspect)로 분리하여 관리한다.

비즈니스 로직(핵심 기능)과 공통 기능(부가 기능)을 분리해 관심사의 분리(Separation of Concerns)를 실현한다.

---

## <mark>3. 주요 개념</mark>

- **Aspect** : 부가 기능을 담은 모듈 (예: 로깅, 보안, 트랜잭션)
- **Join Point** : 부가 기능이 적용될 수 있는 실행 지점 (예: 메서드 호출, 예외 발생 등)
- **Pointcut** : 실제로 Aspect가 적용될 구체적 조건을 정의 (예: `@Service` 클래스의 모든 메서드)
- **Advice** : 언제 어떤 부가 기능을 실행할지 정의 (before, after, around)
- **Weaving** : Aspect를 핵심 로직 코드에 적용하는 과정 (컴파일 시, 로드 시, 런타임 시 가능)

---

## <mark>4. 예시 (Spring AOP 관점)</mark>

- **Before Advice** : 메서드 실행 전에 로그 출력
- **After Returning Advice** : 메서드 정상 종료 후 결과 기록
- **After Throwing Advice** : 예외 발생 시 에러 로그 기록
- **Around Advice** : 메서드 실행 전/후 모두 제어 가능 (트랜잭션 처리 등)

```java
@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("메서드 실행 전: " + joinPoint.getSignature());
    }
}

```

---

👉  **AOP는 공통 기능을 코드에서 분리해 깔끔하고 유지보수하기 좋은 구조를 만드는 기법**이다.

OOP가 **데이터와 기능을 객체 단위로 묶는 것**이라면, AOP는 **여러 객체에 흩어진 공통 기능을 한 군데 모아서 관리**하는 것.

---

# 📌 AOP 대표 활용 사례

## <mark>1. 로깅 (Logging)</mark>

### 문제 상황

- 서비스/DAO 메서드가 실행될 때마다 시작/종료 로그, 파라미터, 실행 시간 등을 기록해야 할 때가 많음.
- 각 메서드에 `System.out.println()` 또는 로깅 코드를 직접 추가하면 **중복**되고, 유지보수가 어려움.

### AOP 적용

- `@Before` → 메서드 시작 전 파라미터 로그 출력
- `@AfterReturning` → 메서드 정상 종료 후 결과 로그 출력
- `@AfterThrowing` → 예외 발생 시 에러 로그 출력

```java
@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore(JoinPoint jp) {
        System.out.println("▶ 실행 메서드: " + jp.getSignature());
        System.out.println("▶ 파라미터: " + Arrays.toString(jp.getArgs()));
    }

    @AfterReturning(pointcut = "execution(* com.example.service.*.*(..))", returning = "result")
    public void logAfter(Object result) {
        System.out.println("▶ 결과: " + result);
    }

    @AfterThrowing(pointcut = "execution(* com.example.service.*.*(..))", throwing = "ex")
    public void logError(Exception ex) {
        System.err.println("▶ 예외 발생: " + ex.getMessage());
    }
}

```

---

## <mark>2. 보안 (Security)</mark>

### 문제 상황

- 특정 서비스/메서드는 인증(Authentication)이나 권한(Authorization)이 필요.
- 예: "관리자 전용 API"는 ADMIN 권한이 있는 사용자만 실행 가능해야 함.
- 보안 체크를 각 메서드마다 넣으면 중복 + 변경이 어려움.

### AOP 적용

- `@Before` Advice에서 로그인 여부, 권한 검사.
- 조건 불충족 시 바로 예외 발생 → 핵심 로직 접근 차단.

```java
@Aspect
@Component
public class SecurityAspect {

    @Before("execution(* com.example.service.AdminService.*(..))")
    public void checkAdminRole() {
        // 예: SecurityContextHolder에서 유저 정보 가져오기
        String role = SecurityContextHolder.getContext().getAuthentication().getAuthorities().toString();
        if (!role.contains("ADMIN")) {
            throw new SecurityException("관리자 권한이 필요합니다.");
        }
    }
}

```

---

## <mark>3. 트랜잭션 처리 (Transaction Management)</mark>

### 문제 상황

- DB 작업은 원자성(Atomicity) 보장이 필요.
- 여러 DAO 호출 중 하나라도 실패하면 전체 롤백해야 함.
- 각 메서드마다 try-catch + 롤백 코드를 넣는 건 비효율적.

### AOP 적용 (Spring의 `@Transactional` 자체가 AOP 기반)

- 메서드 실행 전 DB 트랜잭션 시작
- 정상 종료 → commit
- 예외 발생 → rollback

```java
@Service
public class OrderService {

    @Transactional  // AOP 기반 트랜잭션 처리
    public void placeOrder(Order order) {
        orderRepository.save(order);
        paymentRepository.charge(order);
        // 하나라도 실패하면 전체 롤백
    }
}

```

- 내부적으로는 **프록시(Proxy) 객체**를 생성해서 메서드 호출을 가로채고, 트랜잭션 시작/종료/롤백을 관리.

---

👉 **핵심 비즈니스 로직과 분리된 공통 관심사**라서 AOP의 진가가 가장 잘 드러나는 영역입니다.

서비스 코드에는 오직 **비즈니스 로직만 남게 되고**, 유지보수와 가독성이 크게 개선됩니다.

---
## ✍️ 오늘의 회고

오늘은 어제에 이어 Spring의 주요 개념 중 하나인 AOP에 대해 배웠다. 이해가 잘 되는 듯하다가도, 아직 코드로 직접 구현해보지 않아서 그런지 낯설게 느껴진다. 그래도 정리본에서 볼 수 있듯이 상황에 맞는 예시 코드를 통해 이해를 넓혀가다 보니, 조금은 더 잘 이해가 된 것 같다. (물론 이걸 실전에서 어떻게 활용할 수 있을지가 관건이겠지만…)

문득 프론트엔드 개발자를 지망하고 있는데, 이런 개념들이 도움이 될까 하는 생각이 들어 잠시 공부를 멈추었다. 하지만 곧 떠오른 건, 내가 너무 파편적으로 나눠서 공부하고 있는 게 아닌가 하는 점이었다. AOP 또한 프론트엔드에서도 적용할 수 있는 개념이고, 지금 배우는 Spring을 꾸준히 학습하다 보면 언젠가는 또 다른 무기가 될 수도 있겠다는 생각이 들었다.ㅎㅎ

곧 연휴가 시작되는데 Spring 과제에도 집중해야 하지만, 연휴 기간에는 토스에서 발행한 Frontend Fundamentals를 읽고 리뷰를 남겨볼 예정이다.

오늘도 수고했고, 내일도 힘내보자 Juncci!
