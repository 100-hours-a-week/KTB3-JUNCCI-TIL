# 📚DB 핵심 개념 정리(DB, 정규화, SQL)

---
## <mark>옵티마이저(Optimizer) </mark>

**옵티마이저**는 데이터베이스가 SQL 문을 실행할 때, 그 쿼리를 **가장 효율적으로 실행할 방법(실행계획, Execution Plan)** 을 자동으로 찾아주는 **쿼리 최적화 엔진**.

> “SQL을 빠르게 실행하기 위한 최적의 경로를 찾는 뇌(두뇌)” 역할.
> 

---

## 옵티마이저의 역할

1. **SQL 문 분석**
    
    → 어떤 테이블을 조회하고, 어떤 조건(`WHERE`, `JOIN`, `GROUP BY` 등)이 있는지 파악
    
2. **통계 정보 확인**
    
    → 각 테이블의 **데이터 건수, 인덱스 존재 여부, 카디널리티(중복도)** 등을 참조
    
3. **여러 실행 방법 시뮬레이션**
    
    → “인덱스를 탈까?”, “풀스캔할까?”, “조인 순서를 바꿀까?” 등 다양한 실행 방법 비교
    
4. **가장 비용이 적은 실행계획 선택**
    
    → **비용기반(cost-based)** 으로 최적의 실행 경로 결정
    

---

## 옵티마이저의 종류

| 구분 | 설명 |
| --- | --- |
| **규칙 기반 옵티마이저 (RBO)** | 미리 정해진 규칙에 따라 실행계획 선택 (예: 인덱스 있으면 무조건 사용) |
| **비용 기반 옵티마이저 (CBO)** | 데이터 통계정보를 기반으로 **비용(cost)** 을 계산해 가장 효율적인 계획 선택 (현대 DB 대부분 이 방식) |

👉 MySQL, Oracle, PostgreSQL 등은 모두 **CBO (Cost-Based Optimizer)** 를 사용.

---

## 예시로 이해하기

```sql
SELECT *
FROM student s
JOIN department d ON s.dept_id = d.dept_id
WHERE d.dept_name = '컴퓨터공학';

```

옵티마이저는 이 쿼리를 실행하기 위해 여러 시나리오를 계산합니다 👇

- `student` 테이블을 먼저 읽을까?
- `department`를 먼저 읽고 필터링한 뒤 `student`와 JOIN할까?
- 인덱스를 타면 I/O가 얼마나 줄까?

➡️ 이 모든 경우의 **비용(Cost)** 을 비교해서, **가장 빠른 실행계획**을 선택합니다.

---

## 옵티마이저가 제대로 동작하지 않을 때

- 통계 정보(Statistics)가 오래되어 **데이터 분포를 잘못 판단할 때**
- 너무 많은 테이블을 JOIN해서 **경우의 수가 폭발적으로 증가할 때**
- **복잡한 서브쿼리나 조건문**으로 인해 실행계획을 잘못 세울 때

➡️ 이런 경우, 옵티마이저는 “최적이 아닌” 실행 경로를 선택해서 쿼리가 느려질 수 있습니다.

---

# <mark> 데이터베이스(Database) 정리 </mark>

---

## 1️⃣ Database (데이터베이스)

### 정의

데이터베이스(Database)는 **체계적으로 데이터를 저장하고 관리하는 시스템.**

단순한 파일 저장이 아니라, 데이터의 **일관성(Consistency)**, **무결성(Integrity)**, **보안성(Security)** 등을 유지하면서 **여러 사용자가 동시에 접근**할 수 있게 해줌.

---

### DB 사용 이유

| 구분 | 설명 |
| --- | --- |
| **데이터의 영속성(Persistence)** | 프로그램이 종료되더라도 데이터가 사라지지 않고 **영구히 저장**됨 |
| **데이터의 안정성(Stability)** | 시스템 장애, 네트워크 단절 등 비정상 상황에서도 데이터가 **손실 없이 복구**됨 |
| **데이터의 무결성(Integrity)** | 데이터가 **정확하고 논리적으로 일관된 상태**를 유지하도록 보장 |
| **데이터의 신뢰성(Reliability)** | 오류·장애가 발생해도 데이터를 **안전하게 관리하고 복원할 수 있는 능력** |
| **데이터의 동시 접근 및 공유** | 여러 사용자가 동시에 같은 데이터를 **읽거나 수정할 수 있음** (Locking, Isolation으로 제어) |

### 용어 정리

- **영속성 (Persistence)**
    
    → 데이터가 프로그램 종료나 서버 재시작 후에도 **영구히 저장**되는 성질
    
    *(예: 회원정보가 서버 재부팅 후에도 유지됨)*
    
- **안정성 (Stability)**
    
    → 장애나 오류 발생 시에도 **데이터 손상·유실 없이 복구** 가능한 성질
    
    *(예: 전원 꺼져도 트랜잭션 로그로 복구 가능)*
    
- **무결성 (Integrity)**
    
    → 데이터가 **정확하고 논리적으로 일관된 상태**를 유지하는 성질
    
    *(예: 존재하지 않는 학과ID를 학생 테이블에 넣지 않음)*
    
- **신뢰성 (Reliability)**
    
    → 시스템 오류 후에도 **정상 작동하며 데이터 신뢰를 유지**하는 능력
    
    *(예: 송금 중 오류 발생 시 자동 롤백)*
    

---

### 핵심 개념

- **DBMS (Database Management System)** : 데이터베이스를 관리하는 소프트웨어 (MySQL, PostgreSQL 등)
- **스키마(Schema)** : 데이터베이스의 구조 정의 (테이블, 컬럼, 관계)
- **트랜잭션(Transaction)** : 데이터베이스 작업의 단위, **ACID 원칙** 준수
    - Atomicity (원자성)
    - Consistency (일관성)
    - Isolation (격리성)
    - Durability (지속성)

---

## 2️⃣ 정규화 (Normalization)

### 정의

정규화는 **데이터 중복을 최소화하고, 이상현상(Anomaly)을 방지하기 위한 데이터 구조화 과정**.

**함수 종속성(Functional Dependency)** 을 기반으로 테이블을 분리하여,

데이터를 논리적으로 깔끔하게 정리합니다.

---

### 정규화를 하는 이유

### 1. **중복 최소화**

- 동일한 데이터가 여러 곳에 존재하면 **저장공간 낭비**, **데이터 불일치(Inconsistency)** 가 발생할 수 있음.
- 정규화를 통해 **중복 데이터 제거** → **저장 효율 향상 + 일관성 유지**

### 2. **데이터 구조화**

- 테이블 간 **함수 종속성(Functional Dependency)** 을 분석하여,
    
    “어떤 속성이 다른 속성에 의존하는가?”를 기준으로 테이블을 분리
    
- 이를 통해 데이터 간 관계를 명확히 정의하고 **이상현상(삽입·갱신·삭제 이상) 제거**

---

### 단계별 설명

| 단계 | 이름 | 주요 내용 |
| --- | --- | --- |
| **1NF** | 제1정규형 | 모든 속성은 원자값(더 쪼갤 수 없는 값)을 가져야 함 |
| **2NF** | 제2정규형 | 부분 함수 종속 제거 (복합키의 일부에만 의존하는 속성 제거) |
| **3NF** | 제3정규형 | 이행적 종속(A→B→C) 제거 |
| **BCNF** | 보이스-코드 정규형 | 결정자가 후보키가 아닌 경우 제거 |

---

## 3️⃣ 반정규화

### 정의

반정규화는 **조회 성능 향상을 위해 의도적으로 데이터 중복을 허용하는 과정**.

정규화된 구조는 깔끔하지만 JOIN이 많아지면 성능이 저하될 수 있으므로,

일부 테이블을 병합하거나 중복 컬럼을 추가하여 속도를 높입니다.

---

### 특징

| 구분 | 정규화 | 반정규화 |
| --- | --- | --- |
| 목적 | 무결성, 구조적 일관성 | 조회 성능 향상 |
| 방식 | 데이터 중복 제거 | 중복 허용 |
| 장점 | 일관성, 변경 용이 | JOIN 감소, 빠른 조회 |
| 단점 | JOIN 많아 느릴 수 있음 | 중복 수정, 무결성 저하 가능 |
|  |  |  |

---

### 대표 방법

- **테이블 병합** : 자주 JOIN되는 테이블을 하나로 합침
- **중복 컬럼 추가** : 자주 사용하는 컬럼을 복사 저장
- **집계 컬럼 추가** : 합계, 개수 등을 미리 계산해 저장
- **이력/분할** : 변경 잦은 데이터는 별도 테이블로 분리

---

## 4️⃣ SQL

### 정의

SQL(Structured Query Language)은 **데이터베이스를 조작하기 위한 표준 언어**입니다.

---

### 주요 명령어 분류

| 구분 | 설명 | 예시 |
| --- | --- | --- |
| **DDL** (Data Definition Language) | 테이블 등 구조 정의 | `CREATE`, `ALTER`, `DROP` |
| **DML** (Data Manipulation Language) | 데이터 조작 | `SELECT`, `INSERT`, `UPDATE`, `DELETE` |
| **DCL** (Data Control Language) | 접근 권한 제어 | `GRANT`, `REVOKE` |
| **TCL** (Transaction Control Language) | 트랜잭션 제어 | `COMMIT`, `ROLLBACK`, `SAVEPOINT` |

---
## <mark> 추가 정리본 </mark>
### JOIN을 많이 하면 성능이 떨어지는 이유

| 원인 | 설명 |
| --- | --- |
| **데이터 양 증가** | 두 테이블의 행 수가 많으면 비교 횟수가 기하급수적으로 증가 (예: 10만 × 10만 = 100억 비교) |
| **인덱스 미적용** | JOIN 조건(`ON`) 컬럼에 인덱스가 없으면 **Full Table Scan** 발생 → 대량 I/O 소모 |
| **불필요한 조인** | 실제로 필요하지 않은 테이블까지 매번 연결 → 불필요한 메모리, CPU 사용 |
| **실행계획 비효율** | 옵티마이저(Optimizer)가 잘못된 조인 순서나 방식(Nested Loop, Hash Join 등)을 선택할 경우 성능 급감 |
| **네트워크/메모리 부하** | 대량의 조인 결과를 임시 테이블에 저장하거나, 버퍼 풀을 초과할 때 성능 저하 |
| **쿼리 복잡도 증가** | 너무 많은 테이블을 JOIN하면 쿼리가 복잡해지고, 옵티마이저가 **정확한 실행 계획을 수립하지 못하는 경우가 발생** |

---

### 해결 방법

- 조인 대상 컬럼에 **적절한 인덱스 생성**
- SELECT * 대신 필요한 컬럼만 명시
- **EXPLAIN** 명령어로 실행 계획 확인 및 조정
- 자주 JOIN되는 테이블은 **반정규화(De-Normalization)** 고려
- **Materialized View(물리적 캐시)** 로 자주 사용하는 결과 미리 저장
- 복잡한 쿼리를 **단계별로 분리하거나 임시 테이블로 나누어 처리**

---
