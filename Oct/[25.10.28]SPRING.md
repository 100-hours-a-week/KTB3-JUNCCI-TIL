# 📚 SPRING 핵심 개념 정리(Persistence Context)

---

# <mark> JPA 영속성 컨텍스트 </mark> 

**애플리케이션 구동/요청 → EMF 생성 → EM 생성 → 영속성 컨텍스트 관리 → 트랜잭션 수행/커밋 → DB 동기화**

- **Persistence Unit**: DB 연결/벤더 설정 묶음 (드라이버, URL, 계정, DDL 등, `application.yml` 기반)
- **EntityManagerFactory (EMF)**: 애플리케이션 시작 시 1개 생성(비용 큼), 스레드-세이프
- **EntityManager (EM)**: 요청/트랜잭션 단위로 생성(가벼움), 스레드-언세이프
    
    → **하나의 EM = 하나의 영속성 컨텍스트**
    
- **영속성 컨텍스트**: 메모리 상의 관리 공간(1차 캐시, 쓰기 지연, 변경 감지의 주 무대)
- **DB**: 최종 영구 저장소
    
    > 관계 흐름: EMF → EM → 영속성 컨텍스트 ↔ DB
    > 

---

## <mark> 영속성 컨텍스트의 정의와 역할</mark> 

> 영속성 컨텍스트(Persistence Context)은 엔티티를 관리하는 **논리적 메모리 공간(캐시)** 
> 
> **DB와 애플리케이션 사이의 “중간 버퍼이자 동기화 관리자”** 역할을 수행한다.

---

## <mark>  엔티티 생명주기</mark> 
<img width="625" height="299" alt="스크린샷 2025-10-28 오후 3 28 44" src="https://github.com/user-attachments/assets/0f6beb84-2943-46f6-b48f-945b153f56e9" />

JPA의 핵심은 **엔티티 객체의 상태를 관리하는 것**이며,

이 관리를 담당하는 주체가 바로 **영속성 컨텍스트**다.

엔티티는 다음 네 단계를 거친다:



- **비영속(Transient)**: `new User()` — JPA/DB와 무관한 평범한 객체
- **영속(Persistent)**: `em.persist(user)`, `em.find(...)` — **영속성 컨텍스트가 관리** (1차 캐시/변경 감지/쓰기 지연 대상)
- **준영속(Detached)**: `em.detach(entity)`, `em.clear()`, `em.close()` — **관리 해제**(변경 감지 대상 아님)
- **삭제(Removed)**: `em.remove(entity)` — **삭제 예약 상태**(커밋/flush 때 DB에 DELETE 반영)
---
## <mark>  영속성 컨텍스트의 존재 이유</mark> 

- JPA는 “객체 지향 모델”과 “관계형 DB” 사이의 패러다임 차이를 해결하기 위해 존재
- 영속성 컨텍스트가 없다면, 개발자가 직접 SQL을 매번 작성하고
    
    객체 변경 → SQL 수동 반영 과정을 일일이 처리해야 함
    
- 영속성 컨텍스트는 **이 과정을 자동화**해서
    - **객체 중심 코드 유지**
    - **데이터베이스와 자동 동기화**
    - **성능 최적화(캐싱, 배치)**
    - **일관성 보장**을 달성함.

---

## <mark> 핵심 메커니즘</mark> 

### 3-1. 1차 캐시 (First-Level Cache)

- 범위: **EntityManager 단위**
- 효과: **동일성 보장**(같은 엔티티는 동일 객체), **DB 접근 최소화**
- 흐름: `find()` → 캐시 조회 → 없으면 DB 조회 후 캐시에 저장

```java
Member a = em.find(Member.class, 1L); // DB 조회 → 캐시 저장
Member b = em.find(Member.class, 1L); // 캐시 히트 (DB 미접근)
assert a == b;

```

### 3-2. 쓰기 지연 (Write-Behind)

- `persist()`/변경 시점에 SQL을 **바로 DB로 보내지 않고** 내부 버퍼에 저장
- **flush/commit** 시에 한꺼번에 전송 → **배치 처리**로 I/O 감소
- 주의: **`IDENTITY` 전략**은 PK 생성을 위해 **INSERT가 즉시** 필요할 수 있어 배치 이점이 제한됨
    
    (대안: **`SEQUENCE + allocationSize`** 로 배치/성능 최적화)
    

```java
for (int i = 0; i < 100; i++) em.persist(new Member("u"+i, 20));
tx.commit(); // flush → INSERT 일괄 실행

```

### 3-3. 변경 감지 (Dirty Checking)

- **스냅샷**(최초 영속화 상태)과 현재 값을 **flush 시 비교**
- 변경이 있으면 **UPDATE SQL 자동 생성**(개발자가 직접 `update()` 호출 불필요)

```java
Member m = em.find(Member.class, 1L);
m.setName("변경");   // 단순 setter
tx.commit();         // flush 중 UPDATE 자동 생성

```

### 3-4. flush / clear / close 구분

- **flush()**: SQL 동기화만 수행(캐시는 유지)
- **clear()**: 컨텍스트 비우기(모두 준영속)
- **close()**: 컨텍스트 종료(EM 재사용 불가)

---

## <mark> OSIV (Open Session In View)</mark> 

- **OSIV**는 웹 요청이 끝날 때까지 EntityManager(=영속성 컨텍스트)를 열어두는 설정.
    
    트랜잭션이 끝난 후에도 LAZY 로딩이 가능하지만,
    
    서비스 계층 밖에서 엔티티를 접근하게 되므로 **N+1 문제**나 **의도치 않은 쿼리**가 발생할 수 있음.
    
- 실무에서는 **OSIV 비활성화(`spring.jpa.open-in-view=false`)** 후,
    
    **서비스 계층에서 모든 로딩을 완료하고 DTO로 반환**하는 패턴을 권장.



✍️ 오늘의 회고
요즘 공부에 소홀해지고 있는 것 같다.
부트캠프에서 백엔드 중심의 수업을 듣고 있지만, 스스로 핑계를 대며 그만두고 싶다는 생각이 자주 든다.
생각이 많아져서인지 집중도 잘 안 되고, 나태해져서 수업 시간에 졸기까지 한다.

요즘 가장 많이 하는 생각은 ‘내가 정말 개발자가 되고 싶은 걸까?’ 하는 것이다.
처음엔 분명 열정이 있었는데, 요즘은 그 마음이 흐려진 것 같다.
그래도 후회하지 않으려면 다시 마음을 다잡고 나아가야 한다.
다시 예전의 의욕을 되찾고 싶다.
