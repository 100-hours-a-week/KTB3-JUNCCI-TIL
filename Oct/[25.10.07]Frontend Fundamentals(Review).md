# Frontend Fundamentals - 가독성II
이번 글은 [**Frontend Fundamentals**](https://frontend-fundamentals.com/code-quality/)의 **좋은 코드의 기준 알아보기** 섹션을 리뷰한 글이에요.  
이번에는 **‘가독성(Readability)’** 파트 중  
**이름 붙이기(Name Things)** 와 **위에서 아래로 읽히게 하기(Top-Down Reading)**  
두 가지 주제를 중심으로 정리해봤습니다 :)

---

## 목차 

### **[이름 붙이기]**

* 복잡한 조건에 이름 붙이기
* 매직 넘버에 이름 붙이기

### **[위에서 아래로 읽히게 하기]**

* 시점 이동 줄이기
* 삼항 연산자 단순화

---

## <mark> ✏️ [이름 붙이기] 복잡한 조건에 이름 붙이기 ✏️ </mark>

### ❌ 맥락 없는 조건식 ❌

```js
if (user.age > 18 && user.country === "KR" && user.hasSubscription && !user.isBanned) {
  grantAccess();
}
```

짧지만 읽는 순간 멈칫하죠.
‘이 조건은 무슨 뜻일까?’, ‘무엇을 체크하려는 걸까?’ 하고요.
이건 **조건이 의도를 표현하지 못한 상태**입니다.

---

### ✅ 개선: 조건에 의미를 부여 ✅

```js
const isEligibleKoreanAdult = 
  user.age > 18 && user.country === "KR" && user.hasSubscription && !user.isBanned;

if (isEligibleKoreanAdult) grantAccess();
```

한 줄짜리 **변수명**만 추가했을 뿐인데, 코드의 의도가 명확해졌습니다.
읽는 순간 “한국의 성인 구독 사용자 중 밴되지 않은 경우”임을 바로 알 수 있죠.

---

### 💡 언제 이름을 붙여야 할까? 💡

![file\_KbOzrZGfy6nJ0KClYF](https://exp-upload.goorm.io/2025-10-07/á/KbOzrZGfy6nJ0KClYFwebp)

> 💭 조건문을 읽으면서 잠깐이라도 “이게 뭘 의미하지?”라고 멈칫한다면,
> 그건 이름을 붙여야 한다는 신호예요.
>
> (개인적인 생각) 위의 상황들은 절대적인 기준이라기보다 권장 사항에 가깝습니다.
> 결국 중요한 것은 코드의 맥락과 팀의 합의이며,
> 상황에 맞게 유연하게 적용하는 것이 가장 바람직하다고 생각해요.

---

##  <mark> 🔢 [이름 붙이기] 매직 넘버에 이름 붙이기 🔢 </mark>

### ❌ 맥락 없는 숫자

```js
setTimeout(fetchData, 300);
```

이 300이 어떤 의미일까요?
API 대기 시간일 수도, 애니메이션 딜레이일 수도 있겠죠.
의미가 불분명한 숫자는 **코드의 의도를 흐립니다.**

---

### ✅ 개선: 명시적인 이름으로 바꾸기 ✅

```js
const ANIMATION_DELAY_MS = 300;
setTimeout(fetchData, ANIMATION_DELAY_MS);
```

이제 300이라는 숫자는 단순한 값이 아니라
“애니메이션이 끝나기까지 기다리는 시간”이라는 명확한 맥락을 가집니다.

> 💭 예전에는 매직 넘버를 사용하지 않고 바로 상수를 코드에 넣는 습관이 있었는데,
> 이 글을 읽으면서 그로 인해 오히려 가독성이 떨어졌다는 걸 깨달았어요.
> 여러분도 이 글을 계기로, 자신의 코드를 다시 돌아보며
> “의도를 드러내는 이름이 있는 코드”를 함께 고민해보시길 추천드립니다.
> (소 잃고 나서라도 외양간은 꼭 고쳐야 합니드앗!)

---

### (추가) 변수 이름 짓는 규칙

변수 이름 짓는 방법, 다들 알고 계신가요? 😊
변수 이름을 정할 때는 **의미 있는 변수명**을 사용하는 것도 중요하지만,
그만큼 **일관된 네이밍 컨벤션을 지키는 것**도 아주 중요합니다.

프로그래밍 언어마다 자주 사용하는 네이밍 방식이 조금씩 다르기 때문에,
이번 글에서는 대표적인 컨벤션들을 함께 정리해보았습니다.
물론, 무엇보다 중요한 건 **팀 내에서 어떤 규칙을 함께 지킬지 합의하는 것**이에요!

![file\_zTPB7e6G4afj1FF26q](https://exp-upload.goorm.io/2025-10-07/á/zTPB7e6G4afj1FF26qwebp)

> (추가) 상수는 **대문자 스네이크 케이스(UPPER_SNAKE_CASE)** 로 표현합니다.

```js
const API_TIMEOUT_MS = 5000;
function getUserInfo() {}
class UserProfile {}
```

---

##  <mark>🔄 [위에서 아래로 읽히게 하기] 시점 이동 줄이기 🔄  </mark>

### 🧩 시점 이동이란?

코드를 읽을 때,
“이 값이 어디서 왔지?”, “이 함수는 뭘 리턴하지?” 하며
위아래를 계속 오가야 하는 상황을 **시점 이동**이라고 해요.

시점 이동이 많으면 코드를 읽는 흐름이 끊기고,
한 번에 기억해야 하는 정보가 많아져 **인지 부하(cognitive load)** 가 커집니다.

---

### ❌ 시점 이동이 잦은 코드 ❌

```js
function Page() {
  const user = useUser();
  const policy = getPolicyByRole(user.role);

  return (
    <div>
      <Button disabled={!policy.canInvite}>Invite</Button>
      <Button disabled={!policy.canView}>View</Button>
    </div>
  );
}

function getPolicyByRole(role) {
  const policy = POLICY_SET[role];
  return {
    canInvite: policy.includes("invite"),
    canView: policy.includes("view"),
  };
}

const POLICY_SET = {
  admin: ["invite", "view"],
  viewer: ["view"],
};
```

이 코드의 문제는 단순합니다.
“Invite 버튼이 비활성화된 이유”를 이해하려면

1️⃣ `policy.canInvite`가 뭘 의미하는지 보기 위해 `getPolicyByRole()`로 이동
2️⃣ 그 함수 안의 `POLICY_SET`을 또 확인
3️⃣ 다시 `user.role`이 어디서 오는지도 추적해야 함

**한 기능을 이해하기 위해 세 번의 시점 이동이 발생**합니다.

---

### 🧠 문제의 본질 🧠

이런 추상화는 “권한 체계가 복잡한 서비스”라면 필요합니다.
하지만 지금처럼 단순한 두 가지 역할(`admin`, `viewer`)만 존재한다면
오히려 가독성을 해칩니다.

**추상화는 단순한 코드를 복잡하게 만들 수도 있습니다.**

---

### ✅ 개선: 조건을 그대로 드러내기 ✅

복잡한 정책 로직을 “그냥 코드에 드러내기”만 해도
시점 이동이 확 줄어듭니다.

```js
function Page() {
  const user = useUser();

  if (user.role === "admin") {
    return (
      <div>
        <Button disabled={false}>Invite</Button>
        <Button disabled={false}>View</Button>
      </div>
    );
  }

  if (user.role === "viewer") {
    return (
      <div>
        <Button disabled={true}>Invite</Button>
        <Button disabled={false}>View</Button>
      </div>
    );
  }

  return null;
}
```

이제 **코드를 위에서 아래로 한 번만 읽으면**
“관리자는 둘 다 가능, 뷰어는 Invite만 막힘”이라는 흐름이 그대로 보입니다.

> 이렇게 ‘요구사항을 코드에 직접 표현’하는 방식은
> 추상화를 포기하는 게 아니라, **맥락을 드러내는 선택**이에요.

---

### ✅ 또 다른 개선 방식: 객체로 한눈에 관리 ✅

권한이 늘어날 수 있다면, 조건 대신 객체로 관리하는 방법도 있습니다.

```js
function Page() {
  const user = useUser();

  const POLICY = {
    admin: { canInvite: true, canView: true },
    viewer: { canInvite: false, canView: true },
  };

  const { canInvite, canView } = POLICY[user.role];

  return (
    <div>
      <Button disabled={!canInvite}>Invite</Button>
      <Button disabled={!canView}>View</Button>
    </div>
  );
}
```

이제 **시점 이동은 단 한 번만** 일어나죠.
로직을 바로 확인할 수 있고, 정책이 추가될 때도 코드 흐름을 해치지 않습니다.

---

###  메모리 효율 vs 시점 이동

시점 이동을 줄이면 코드가 조금 길어지거나 중복이 생길 수 있습니다.
반대로, 함수로 추상화하면 코드가 깔끔하지만
이해하려면 파일을 계속 탐색해야 하죠.

이건 **“메모리 효율”과 “인지 효율”의 트레이드오프**입니다.
**실행 성능보다 ‘읽는 사람의 두뇌 성능’을 우선해야 할 때가 많다**는 뜻이에요.

> **개인적 경험담**
> 저 역시 초기에 함수화, 추상화를 많이 했는데
> 유지보수 시점에 “이게 어디서 오는 로직이지?” 하며 파일을 열고 닫기를 반복했어요.
> 지금은 ‘한눈에 읽히는 코드’가 훨씬 더 생산적이라고 생각합니다.
> (라고 1년차 병아리 개발자의 의견을 어필해봅니닷..)

---

##  <mark> ▶️ [위에서 아래로 읽히게 하기] 삼항 연산자 단순화 ◀️ </mark>

### ❌ 중첩된 삼항 연산자 ❌

```js
const status = A && B ? "BOTH" : A ? "A" : B ? "B" : "NONE";
```

짧지만, 읽는 순간 뇌가 바빠지죠.
삼항이 세 겹 이상 중첩되면, 조건의 구조가 흐릿해집니다.

---

### ✅ 개선: 명시적으로 풀어쓰기 ✅

```js
let status;
if (A && B) status = "BOTH";
else if (A) status = "A";
else if (B) status = "B";
else status = "NONE";
```

길어졌지만, 코드를 **위에서 아래로 그대로 읽으면 논리가 보입니다.**
가독성은 “짧음”보다 “명확함”이 더 중요해요.

---

### 💡 Pattern Matching 문법 (JS 제안 중)

한 댓글에서 **ECMAScript에서 제안 중인 Pattern Matching 문법**을 언급하신 걸 보고 흥미로워서 가져와 봤습니다.
이 문법은 **조건을 데이터 패턴으로 풀어내 보다 선언적으로 표현할 수 있게 해주는 기능**이라고 해요.

복잡한 조건문을 더 직관적이고 깔끔하게 표현할 수 있어서,
앞으로 실무에서도 유용하게 쓰일 수 있을 것 같아요.

```js
match ([A, B]) {
  when ([true, true]) -> "BOTH"
  when ([true, false]) -> "A"
  when ([false, true]) -> "B"
  else -> "NONE"
}
```

if/else보다 구조가 명확하고,
조건 분기가 많을수록 **읽기 편한 구조**로 바뀝니다.
👉 [TC39 Pattern Matching Proposal](https://github.com/tc39/proposal-pattern-matching)

---

조건부 렌더링에도 여러 방식이 존재하고, 개발자마다 선호가 갈리더라고요.

Toss의 토론 글([링크](https://github.com/toss/frontend-fundamentals/discussions/4))을 보면,
`&&` **/ 삼항 연산자 방식과** `<If>` **／** `<SwitchCase>` **같은 선언적 컴포넌트 방식 두 가지 모두 지지하는 의견이 많아요.**

* 연산자 방식은 타입 안정성과 직관성이 강점으로 자주 선택되고,
* 선언적 방식은 조건과 렌더링 구조를 분리해 보여주는 점이 매력적으로 평가되죠.

![file\_iPA9BucTGMADkmuR05](https://exp-upload.goorm.io/2025-10-07/á/iPA9BucTGMADkmuR05webp)

어느 쪽이 옳다기보다는, 팀의 스타일과 코드 복잡도에 맞춰 선택하는 게 가장 중요하겠어요.

---
✍️ 제목: 가독성, 보이지 않던 문제를 마주하다.

이틀 동안 추석 연휴를 보내고 다시 마음을 다잡으며 Frontend Fundamentals - 가독성 파트를 읽었다. 글을 읽으며 내가 이전에 작성했던 코드를 함께 살펴봤는데,
생각보다 놓치고 있던 부분이 많다는 걸 깨달았다.

가독성은 에러처럼 바로 드러나는 문제가 아니라,‘다른 개발자가 내 코드를 얼마나 쉽게 읽을 수 있는가’의 문제라서
평소에는 간과하기 쉽지만 정말 중요한 부분이라는 걸 다시금 느꼈다.

앞으로는 기능 구현뿐만 아니라, 이 코드가 다른 사람에게 얼마나 읽히는가를 한 번 더 고민하며 작성해야겠다.
코드는 결국 함께 읽는 문서이니까. 

