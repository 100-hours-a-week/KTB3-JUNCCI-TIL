# Frontend Fundamentals - 가독성I
이번 글은 [**Frontend Fundamentals**](https://frontend-fundamentals.com/code-quality/)의 **좋은 코드의 기준 알아보기** 섹션을 리뷰한 글이에요.  
이번에는 **‘가독성(Readability)’** 파트 중  
**맥락줄이기** 를 중심으로 정리했습니다 :)

---

## 읽기 전에 알고 가면 좋은 용어 정리

### **추상화 (Abstraction)**

복잡한 내부 동작을 숨기고, **의도나 역할만 드러내는 것**.
즉, 코드를 읽는 사람에게 **불필요한 세부 구현은 감추고**,
“이 코드가 무슨 역할을 하는지”만 보이게 만든다.

예시

```tsx
AuthGuard(LoginPage)
```

이 이름만 봐도 “로그인 보호용 페이지”임을 바로 알 수 있다.

---

### **HOC (Higher-Order Component)**

React에서 **컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 함수**.
주로 인증, 로깅, 공통 UI 처리 등 **재사용 가능한 로직을 감싸는 패턴**으로 사용된다.

예시

```tsx
export default withAuthGuard(LoginPage);
```

---

### **useCallback**

렌더링될 때마다 함수를 새로 만드는 것을 방지하는 **성능 최적화 Hook**.
React 함수형 컴포넌트는 렌더링 시 내부 코드가 다시 실행되므로,
함수 안에서 선언된 모든 함수가 새로 만들어진다.
`useCallback`은 이를 **기억(memoization)** 하여 불필요한 함수 생성을 막는다.

예시

```tsx
const handleClick = useCallback(() => {
  console.log("Clicked!");
}, []);
```

---

## 1️⃣ 동시에 실행되지 않는 코드는 분리하자 

### ❌ 기존 코드

```tsx
function SubmitButton() {
  const isViewer = useRole() === "viewer";

  useEffect(() => {
    if (!isViewer) showAnimation();
  }, [isViewer]);

  return isViewer
    ? <button disabled>제출</button>
    : <button>제출</button>;
}
```

이 코드는 한눈에 봐도 `viewer`와 `admin`의 로직이 한곳에 뒤섞여 있다.
즉, 동시에 실행되지 않는 코드를 한 함수 안에서 함께 다루고 있는 것이다.
읽는 사람은 “이 경우엔 여길 보고, 저 경우엔 저길 봐야 하는” 두 가지 맥락을 동시에 따라가야 한다.

---

### ✅ 개선된 코드

```tsx
function SubmitButton() {
  const isViewer = useRole() === "viewer";
  return isViewer ? <ViewerButton /> : <AdminButton />;
}

function ViewerButton() {
  return <button disabled>제출</button>;
}

function AdminButton() {
  useEffect(showAnimation, []);
  return <button>제출</button>;
}
```

이제 각 컴포넌트는 자기 역할에만 집중한다.
뷰어는 비활성 버튼, 관리자는 애니메이션을 가진 버튼.
한눈에 어떤 역할을 하는지 바로 이해된다.

---

### <mark> ⚙️ 공통 컴포넌트로 확장하기 </mark>

두 버튼이 같은 스타일이나 속성을 공유해야 한다면,
**공통 베이스 컴포넌트(Base Component)** 를 만들어 확장할 수도 있다.

```tsx
function BaseButton({ disabled, onClick }) {
  return (
    <button disabled={disabled} onClick={onClick}>
      제출
    </button>
  );
}

function SubmitButton() {
  const isViewer = useRole() === "viewer";
  return isViewer
    ? <BaseButton disabled />
    : <BaseButton onClick={showAnimation} />;
}
```

**정리**

1. 한 컴포넌트 안에서 분기 제거
2. 역할별로 완전 분리
3. 공통 UI는 베이스 컴포넌트로 묶기

---

## <mark>2️⃣ 구현 상세를 추상화로 감추기 (Wrapper & HOC)<mark>

로그인된 사용자는 홈으로 이동시키는 로직을 가진 로그인 페이지를 생각해보자.

### ❌ 기존 코드

```tsx
function LoginStartPage() {
  useCheckLogin({
    onChecked: (status) => {
      if (status === "LOGGED_IN") {
        location.href = "/home";
      }
    },
  });

  return <LoginForm />;
}
```

이 코드는 내부 로직이 모두 드러나 있다.
즉, “로그인 페이지”의 의도보다 **“어떻게 동작하는지”가 먼저 보이는 코드**다.

---

### ✅ 개선 방법 A — Wrapper 컴포넌트

```tsx
function App() {
  return (
    <AuthGuard>
      <LoginStartPage />
    </AuthGuard>
  );
}

function AuthGuard({ children }) {
  const isLoggedIn = useCheckLoginStatus() === "LOGGED_IN";

  useEffect(() => {
    if (isLoggedIn) location.href = "/home";
  }, [isLoggedIn]);

  return isLoggedIn ? null : children;
}
```

이제 `LoginStartPage`는 **로그인 화면만**,
`AuthGuard`는 **인증 제어만** 담당한다.
서로의 역할이 명확히 구분된다.

---

### ✅ 개선 방법 B — HOC 방식

```tsx
function LoginStartPage() {
  return <LoginForm />;
}

export default withAuthGuard(LoginStartPage);

function withAuthGuard(Wrapped) {
  return function AuthGuard(props) {
    const isLoggedIn = useCheckLoginStatus() === "LOGGED_IN";

    useEffect(() => {
      if (isLoggedIn) location.href = "/home";
    }, [isLoggedIn]);

    return isLoggedIn ? null : <Wrapped {...props} />;
  };
}
```

`withAuthGuard(LoginStartPage)` 한 줄만 봐도
“이 페이지는 로그인 보호가 걸려 있다”는 걸 바로 알 수 있다.
이게 바로 **추상화된 코드의 가독성**이다.

---

## <mark>3️⃣ 자주 함께 수정되는 코드는 가까이 두자</mark>

### ❌ 기존 코드

```tsx
function FriendInvitation() {
  const handleClick = async () => {
    const ok = await confirm("초대할까요?");
    if (ok) sendInvite();
  };

  return (
    <>
      <button onClick={handleClick}>초대하기</button>
      {/* 다른 UI ... */}
    </>
  );
}
```

버튼과 로직이 떨어져 있으면
“이 버튼이 어떤 동작을 하는지” 바로 파악하기 어렵다.
로직이 길어질수록 응집도가 낮아진다.

---

### ✅ 개선된 코드

```tsx
function FriendInvitation() {
  return <InviteButton name="지훈" />;
}

function InviteButton({ name }) {
  const handleInvite = async () => {
    const ok = await confirm(`${name}님을 초대할까요?`);
    if (ok) sendInvite();
  };

  return <button onClick={handleInvite}>초대하기</button>;
}
```

버튼과 로직이 **물리적으로도 가깝고**,
이 컴포넌트만 봐도 역할이 명확하다.
응집도가 높아지고, 수정 시 실수할 여지도 줄어든다.

---

## 4️⃣ 로직 종류에 따라 합쳐진 함수 쪼개기

서로 다른 종류의 로직(쿼리 파라미터, 상태, API 호출 등)을
한 Hook 안에 다 넣는 것은 좋지 않다.

### ❌ 기존 코드

```tsx
export function usePageState() {
  const [query, setQuery] = useQueryParams({
    cardId: NumberParam,
    dateFrom: DateParam,
    dateTo: DateParam,
  });

  return {
    cardId: query.cardId,
    dateFrom: query.dateFrom,
    dateTo: query.dateTo,
    setCardId: (v) => setQuery({ cardId: v }),
    setDateFrom: (v) => setQuery({ dateFrom: v }),
    setDateTo: (v) => setQuery({ dateTo: v }),
  };
}
```

이 Hook은 시간이 지날수록 복잡해지고,
하나만 변경되어도 전체가 리렌더링되는 문제가 생긴다.

---

### ✅ 개선된 코드

```tsx
export function useCardIdParam() {
  const [cardId, setCardId] = useQueryParam("cardId", NumberParam);
  return [cardId, setCardId];
}

export function useDateFromParam() {
  const [dateFrom, setDateFrom] = useQueryParam("dateFrom", DateParam);
  return [dateFrom, setDateFrom];
}
```

Hook을 역할 단위로 나누면
**가독성**, **유지보수성**, **성능**이 모두 좋아진다.

---

## 💬 댓글에 나온 질문 정리

### Q1. 인라인 핸들러로 써도 되나요?

아래 두 코드는 기능상 같다.

```tsx
<Button onClick={() => sendInvite()} />

// vs
const handleClick = () => sendInvite();
<Button onClick={handleClick} />
```

* **짧은 로직**이라면 인라인으로 충분
* **복잡하거나 재사용**이 필요하다면 함수로 분리
* 자식 컴포넌트가 `React.memo`로 감싸져 있고
  `onClick`이 자주 바뀐다면 **useCallback으로 고정**하는 게 좋다.

```tsx
const handleClick = useCallback(() => sendInvite(), []);
```

---

## 🧭 마무리

좋은 코드는 똑똑한 코드가 아니라 **읽기 쉬운 코드**다.
읽는 사람이 동시에 고려해야 할 맥락이 적을수록
코드의 품질은 높아진다.

| 나쁜 코드              | 좋은 코드            |
| ------------------ | ---------------- |
| 여러 역할이 한 파일에 섞임    | 역할별 컴포넌트로 분리     |
| 내부 구현이 그대로 노출      | Wrapper/HOC로 감춤  |
| 버튼과 로직이 멀리 있음      | 가까이 위치시켜 응집도 높이기 |
| 다양한 로직이 한 Hook에 몰림 | 역할별 Hook으로 분리    |

*코드는 기능보다 맥락이 문제다.
불필요한 맥락을 줄이면 코드가 읽히기 시작한다.*

---


