# Spring Bean Lifecycle

---

## 개념

**Bean Lifecycle**이란,

> Spring IoC 컨테이너가 **Bean을 생성 → 의존성 주입 → 초기화 → 사용 → 소멸** 시키는 전 과정을 관리하는 구조입니다.
> 

Spring이 Bean의 생명주기를 제어함으로써

객체 생성 시점, 의존성 연결 시점, 자원 해제 시점을 일관되게 관리할 수 있습니다.

---

## 단계별 설명

| 단계 | 동작 | 주요 메서드 / 어노테이션 | 설명 |
| --- | --- | --- | --- |
| **1. 인스턴스화 (Instantiation)** | Bean 객체 생성 | 생성자 | Spring이 Bean을 메모리에 올림 (`new` 호출) |
| **2. 의존성 주입 (Dependency Injection)** | 필요한 Bean, 값 주입 | `@Autowired`, `@Value`, `@Resource` | 다른 Bean이나 설정값을 주입 |
| **3. Aware 콜백 (Aware Callback)** | 컨테이너 정보 접근 | `BeanNameAware`, `ApplicationContextAware` 등 | Bean이 자신의 이름, Context 정보 등을 받을 수 있음 |
| **4. 전처리 (Pre-processing)** | 초기화 전 Bean 가공 | `BeanPostProcessor.postProcessBeforeInitialization()` | 프록시 생성, AOP 설정 등 초기화 전 작업 |
| **5. 초기화 (Initialization)** | Bean 사용 준비 단계 | `@PostConstruct`, `InitializingBean.afterPropertiesSet()`, `init-method` | Bean이 완전히 주입된 후 실행되는 초기 준비 로직 |
| **6. 후처리 (Post-processing)** | 초기화 후 Bean 가공 | `BeanPostProcessor.postProcessAfterInitialization()` | Bean을 Proxy로 감싸거나 추가 설정 적용 |
| **7. 사용 (Use)** | 서비스 로직 수행 | — | Controller, Service 등에서 Bean이 사용되는 시점 |
| **8. 소멸 (Destruction)** | 자원 정리 및 종료 | `@PreDestroy`, `DisposableBean.destroy()`, `destroy-method` | 컨테이너 종료 시 Bean이 사용한 자원 해제 |

---

## 3️⃣ `@PostConstruct` 와 `@PreDestroy` 어노테이션

이 두 어노테이션은 **Bean의 초기화와 소멸 시점에 자동으로 호출되는 메서드**를 지정하기 위해 사용됩니다.

→ **직접 인터페이스를 구현하지 않고도** 간단히 초기화·정리 코드를 실행할 수 있습니다.

### `@PostConstruct`

- **의미**: Bean 생성 및 의존성 주입이 완료된 직후 호출.
- **사용 목적**: Bean이 완전히 준비된 후 실행할 초기화 로직을 넣음.
- **예시 역할**
    - DB 연결 풀 준비
    - 초기 캐시 로딩
    - 설정 파일 검증
    - 로그 초기화 등

**호출 시점**

`BeanPostProcessor.postProcessBeforeInitialization()` 이후,

`InitializingBean.afterPropertiesSet()` 이전.

---

### `@PreDestroy`

- **의미**: 컨테이너 종료 전에 Bean이 소멸되기 직전 호출.
- **사용 목적**: Bean이 사용한 리소스를 안전하게 해제하거나 저장.
- **예시 역할**
    - DB 커넥션 종료
    - ThreadPool, KafkaProducer, Redis 연결 해제
    - 파일 핸들 닫기
    - 로그 마무리 처리 등

**호출 시점**

`context.close()` 또는 Spring이 종료 신호를 받을 때 실행됨.

이후 `DisposableBean.destroy()`가 호출됩니다.

---

## 4️⃣ Bean Lifecycle을 알아야 하는 이유

| 이유 | 설명 |
| --- | --- |
| **1. 안정적인 초기화/소멸 처리** | Bean의 생성 및 종료 시점에 자원을 정확히 관리할 수 있음 |
| **2. 시점 문제 해결** | `@Autowired` null 문제, Proxy 관련 오류 등을 이해하고 해결 가능 |
| **3. 프레임워크 확장 가능** | BeanPostProcessor, ApplicationListener 등 구현 가능 |
| **4. 리소스 관리 효율화** | 커넥션, 캐시, 스레드 등 시스템 자원 누수 방지 |
| **5. Spring 작동 원리 이해** | IoC, DI, AOP 등 내부 메커니즘의 기초 개념이 Bean 생명주기 위에 존재함 |

---

# Spring Bean Scope

---

## 개념

**Bean Scope**란

> Spring IoC 컨테이너에서 하나의 Bean 정의(클래스) 가
> 
> 
> **얼마나 오래, 어떤 범위에서** 유지될지를 결정하는 설정이에요.
> 
- Bean이 **한 번만 생성되어 전체에서 공유될지**,
- 아니면 **요청마다, 세션마다 새로 만들어질지** 를 정하는 거예요.

---

## 2️⃣ 주요 Scope 종류 (6가지)

| Scope 이름 | 생성 시점 | 소멸 시점 | 사용 위치 | 설명 |
| --- | --- | --- | --- | --- |
| **singleton**  | 컨테이너 시작 시 1회 생성 | 컨테이너 종료 시 | 기본 (전역) | **기본값**. 하나의 Bean 인스턴스를 전 애플리케이션에서 공유 |
| **prototype**  | Bean 요청 시마다 | 가비지 컬렉션 시 (Spring이 관리 안함) | 모든 계층 | 매번 새로운 Bean 인스턴스를 생성 |
| **request**  | HTTP 요청 시작 시 | 요청 종료 시 | Web Layer (Controller 등) | HTTP 요청당 Bean 1개 생성 |
| **session**  | HTTP 세션 시작 시 | 세션 만료 시 | Web Layer | 세션당 Bean 1개 생성 |
| **application**  | ServletContext 시작 시 | ServletContext 종료 시 | Web Layer | 애플리케이션 전역 1개 (웹 컨텍스트 기준) |
| **websocket**  | WebSocket 연결 시작 시 | 연결 종료 시 | WebSocket 환경 | WebSocket 연결마다 Bean 1개 생성 |

---

## 3️⃣ 가장 많이 쓰이는 두 가지: Singleton vs Prototype

### **Singleton**

- **하나의 인스턴스를 모든 요청에서 공유.**
- 애플리케이션 구동 시 Bean이 한 번만 생성됨.
- 메모리 절약, 성능 효율적.
- 단, **상태를 가지면(Thread-Safe하지 않으면)** 위험.

```java
@Component
@Scope("singleton") // 생략 가능 (기본값)
public class SingletonBean {
    ...
}

```

**특징**

- 동일한 Bean을 여러 곳에서 주입해도 같은 인스턴스.
- 공유 자원(Repository, Service)에 적합.

---

### **Prototype**

- **요청할 때마다 새로운 Bean 생성.**
- 각 사용자가 독립된 인스턴스를 사용.
- Spring이 “생성”까지만 관리하고 “소멸”은 직접 책임져야 함.

```java
@Component
@Scope("prototype")
public class PrototypeBean {
    ...
}

```

**특징**

- 매번 새로 만들어야 하는 객체에 적합 (ex. 임시 작업 객체)
- Singleton과 함께 쓰면 주의 필요 (Prototype은 주입 시 1회만 생성됨)

---

## 4️⃣ Web 관련 Scope (request, session, application)

이 Scope들은 **Spring MVC** 같은 **웹 애플리케이션 컨텍스트**에서만 사용 가능해요.

일반 Java 애플리케이션에서는 사용할 수 없습니다.

| Scope | 동작 예시 |
| --- | --- |
| **request** | 사용자가 A 페이지 요청 → 새로운 Bean 생성 → 응답 후 소멸 |
| **session** | 로그인한 사용자마다 세션 생성 → 세션 유지 동안 Bean 유지 |
| **application** | 서버 내 전역적으로 1개 Bean (모든 세션/요청 공유) |

---

## 5️⃣ 주의할 점

| 상황 | 문제 | 해결 방법 |
| --- | --- | --- |
| Singleton Bean에서 Prototype Bean 주입 | Prototype이 1회만 생성됨 | `@Lookup` 메서드 또는 `ObjectProvider` 사용 |
| Stateful Bean을 Singleton으로 등록 | 여러 요청이 동시에 같은 Bean 공유 → 데이터 꼬임 | 반드시 **stateless**하게 설계 |
| Web Scope Bean을 Non-Web Bean에서 사용 | Context 미존재 → 예외 발생 | `@RequestScope`, `@SessionScope`는 웹 환경에서만 사용 |

---

## 6️⃣ 어노테이션 정리

| 어노테이션 | 역할 |
| --- | --- |
| `@Scope("singleton")` | 하나의 Bean만 생성 (기본값) |
| `@Scope("prototype")` | 매 요청마다 새 객체 생성 |
| `@RequestScope` | 요청 단위 Bean |
| `@SessionScope` | 세션 단위 Bean |
| `@ApplicationScope` | 애플리케이션 전체 Bean |
| `@WebSocketScope` | WebSocket 연결 단위 Bean (Spring 5.3+) |

---

## 7️⃣ Bean Lifecycle과 Scope의 관계

| Scope | 생성/소멸 관리 주체 | Lifecycle 특징 |
| --- | --- | --- |
| Singleton | Spring이 전 과정 관리 | 생성~소멸까지 관리됨 |
| Prototype | 개발자가 직접 관리 | 생성만 Spring이 담당 |
| Web Scope | Spring Web Context | 요청, 세션, 앱 등 컨텍스트 단위로 관리 |

> Lifecycle은 “어떤 과정을 거치나”
> 
> 
> **Scope**는 “그 과정이 얼마 동안 지속되나”
> 
> 를 정의한다고 보면 됩니다.
> 

---
