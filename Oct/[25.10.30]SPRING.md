# 📚 SPRING 핵심 개념 정리(JPA - Proxy/JPQL/Fetch Join/Spring Data JPA)


---

## <mark> Proxy </mark>

### 정의

> JPA에서 지연 로딩(Lazy Loading) 을 지원하기 위해 실제 엔티티 대신 만들어지는 가짜 객체.
> 
> 
> 실제 데이터는 없지만, **DB 식별자(ID)** 는 가지고 있다.
> 

---

### 동작 원리

1. `@ManyToOne(fetch = FetchType.LAZY)` 와 같은 지연 로딩 설정된 연관관계에서
    
    엔티티 조회 시, **연관된 객체를 바로 가져오지 않고 프록시 객체를 넣어둔다.**
    
    → 매번 연관관계 엔티티 객체를 가져오는 것이 아니므로 프록시를 통해 관리
    
2. 나중에 코드에서 해당 프록시의 실제 데이터(`user.getName()`)를 호출하는 순간
    
    → JPA가 그때 SQL을 날려 **진짜 엔티티를 초기화**한다.
    

---

### 예시

```java
Post post = em.find(Post.class, 1L);
User user = post.getUser(); // 이 시점에서는 프록시
System.out.println(user.getClass()); // class com.example.User$HibernateProxy$...

```

이때 `user`는 진짜 `User`가 아니라 Hibernate가 만든 **대리 객체(proxy)** 입니다.

---

### 주의점 — “준영속 상태에서 프록시 초기화”

### 상황 요약

1. Service(@Transactional) 안에서 Post 조회 → User는 Lazy(프록시 상태)
2. 트랜잭션 끝남 → 영속성 컨텍스트 닫힘
3. Controller가 Post를 JSON으로 변환하려고 `post.getUser().getName()` 접근
4. 프록시가 초기화 시도 → **영속성 컨텍스트 없음 → LazyInitializationException**

---

### 해결 방법

1. **DTO로 변환하여 반환**
    - Service 계층 안(트랜잭션 열려 있을 때) DTO 변환 수행
    - Controller에는 DTO만 전달 (Lazy 안전)
2. **Fetch Join 사용**
    - 필요한 연관 엔티티를 쿼리 한 번에 다 가져오기

---

### Proxy를 두는 이유

- **성능 최적화**
    
    → 실제로 필요한 데이터만 로딩 (지연 로딩)
    
- **유연성 확보**
    
    → 객체 그래프를 다 연결하지 않아도, 엔티티 관계 표현 가능
    

---


## <mark> JPQL (Java Persistence Query Language)</mark>

### 정의

> SQL과 비슷하지만, 테이블이 아닌 엔티티 객체(Entity) 를 대상으로 하는 객체지향 쿼리 언어.
> 
> 
> JPA가 JPQL을 분석해 **SQL로 변환하여 DB에 전송**한다.
> 

---

### 왜 필요한가?

- 자바는 **객체지향**, 데이터베이스는 **관계형 구조**
- JPA는 **객체 중심의 데이터 관리**를 위해 등장했지만,
    
    복잡한 조회는 여전히 필요함 → SQL 대신 객체 기준으로 쿼리를 작성할 수 있게 함
    

---

### 예시

```java
SELECT u FROM User u WHERE u.email = :email
```

→ JPA 내부 변환 👇

```sql
SELECT * FROM user WHERE email = ?
```

---

### JPQL 실행 흐름

1. 개발자가 JPQL 작성
2. JPA가 엔티티 매핑 정보를 읽어서 SQL 변환
3. SQL 실행 → 결과를 다시 엔티티 객체로 매핑
4. 영속성 컨텍스트에 저장 (1차 캐시 반영)

---

### JPQL 구문 종류

| 종류 | 설명 | 예시 |
| --- | --- | --- |
| **SELECT** | 엔티티 조회 | `SELECT p FROM Post p` |
| **JOIN** | 연관관계 조인 | `SELECT p FROM Post p JOIN p.user u` |
| **UPDATE / DELETE** | 벌크 연산 | `UPDATE User u SET u.nickname = '로키'` |

---

### JPQL UPDATE의 주의점 (벌크 연산)

- 벌크 연산은 **영속성 컨텍스트를 거치지 않고 DB에 바로 반영**
- DB는 바뀌지만, **1차 캐시의 엔티티는 옛날 데이터 그대로**
    
    → 데이터 불일치 발생!
    

### 해결

- `em.clear()` → 전체 1차 캐시 비우기
- `em.refresh(entity)` → 해당 엔티티만 DB에서 다시 로딩

---

### 요약

> JPQL은 DB의 “테이블”이 아니라,
> 
> 
> JPA의 “엔티티”를 대상으로 하는 **객체 지향 쿼리 언어**이며,
> 
> 영속성 컨텍스트와 연계되어 작동한다.
> 

---

## <mark> Fetch Join (페치 조인) </mark>

### 정의

> 연관된 엔티티를 한 번의 쿼리로 함께 조회하는 기능.
> 
> 
> N+1 문제를 해결하기 위한 가장 강력한 도구 중 하나.
> 

---

### 예시

```java
SELECT p FROM Post p JOIN FETCH p.user
```

→ Post를 조회하면서 연관된 User를 **즉시 함께 로딩**

→ N+1 문제 방지 (추가 쿼리 X)

---

### 컬렉션 Fetch Join의 한계

### ① 두 개 이상 컬렉션 Fetch Join 금지

```java
SELECT u FROM User u
JOIN FETCH u.posts
JOIN FETCH u.comments   ❌

```

→ **카테시안 곱** 발생

→ User × Post × Comment → 데이터 폭발

→ `MultipleBagFetchException` 발생

**한 번의 쿼리에서 컬렉션 Fetch Join은 하나만!**

---

### ② 컬렉션 Fetch Join + 페이징 ❌

```java
SELECT p FROM Post p JOIN FETCH p.comments

```

```java
.setFirstResult(0).setMaxResults(10);

```

→ 조인 결과의 Row 기준으로 페이징되어 **데이터 깨짐**

→ Hibernate 경고: “in-memory paging” 수행 (모든 데이터 로딩 후 페이징)

→ 메모리 폭발 위험

**일대다 컬렉션 Fetch Join 시 페이징 금지**

**다대일, 일대일 Fetch Join은 가능** (Row 수 안 늘어남)

---

### @BatchSize로 대체 가능

```java
@Entity
@BatchSize(size = 100)
public class User {
    @OneToMany(mappedBy = "user")
    private List<Post> posts;
}

```

→ Fetch Join처럼 한 번의 큰 쿼리가 아니라,

Lazy 로딩 시 N개의 쿼리를 IN절 묶음으로 줄여줌

(`WHERE user_id IN (1,2,3,4,5,...)`)

- 원래: `1 + 10 = 11번 쿼리`
- BatchSize: `1 + 1 = 2번 쿼리`

Fetch Join보다 유연하고 페이징 가능

너무 큰 size 설정은 IN절 부하 초래

---

### 요약

> Fetch Join은 즉시 로딩으로 N+1을 해결,
> 
> 
> BatchSize는 **지연 로딩 최적화로 N+1을 완화**한다.
> 
> “Fetch Join은 강력하지만 위험하고, BatchSize는 안정적이다.”
> 

---

# <mark> Spring Data JPA </mark>

---

> Spring Data JPA는 JPA(Java Persistence API)를
> 
> 
> 더 쉽게 사용할 수 있도록 **Spring이 추상화한 데이터 접근 프레임워크**.
> 
> “EntityManager 직접 다루지 않고”,
> 
> “Repository 인터페이스만 정의하면”
> 
> 스프링이 알아서 구현체를 만들어주는 기술.
> 

---

> JPA = 데이터 저장, 수정, 조회를 위한 ORM 기술
> 
> 
> Spring Data JPA = “JPA를 좀 더 개발자 친화적으로 감싸준 도우미”
> 

원래 JPA만 쓰면 이렇게 코딩해야 합니다 👇

```java
public List<User> findByEmail(String email) {
    return em.createQuery("SELECT u FROM User u WHERE u.email = :email", User.class)
             .setParameter("email", email)
             .getResultList();
}

```

하지만 Spring Data JPA에서는 이렇게 끝납니다 👇

```java
List<User> findByEmail(String email);

```

→ 구현체 필요 없음 

→ SQL 작성 필요 없음 

→ 스프링이 자동으로 JPQL 생성 및 실행 

---

## 내부 동작 구조

Spring Data JPA는 사실 **3단계로 구성된 구조물**.

```
[Spring Framework]
     │
     ▼
[Spring Data Commons]
     │
     ▼
[Spring Data JPA]
     │
     ▼
[JPA (Hibernate)]

```

Spring Data JPA는 JPA 위에서 동작하지만,

그 자체도 Spring Data의 하위 모듈이에요.

---

## 동작 원리 (Repository 자동 구현)

### 1️⃣ Repository 인터페이스 정의

```java
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}

```

### 2️⃣ Spring Boot 실행 시점

- 스프링이 `UserRepository` 인터페이스를 감지
- `JpaRepository` 인터페이스의 계층 구조를 분석
- 런타임에 **프록시 객체를 동적으로 생성**
- 내부적으로 `SimpleJpaRepository` 클래스를 구현체로 연결

---

### 3️⃣ 실제로 만들어지는 클래스

```java
public class SimpleJpaRepository<T, ID> implements JpaRepository<T, ID> {
    private final EntityManager em;

    public SimpleJpaRepository(EntityManager em) {
        this.em = em;
    }

    @Override
    public Optional<T> findById(ID id) {
        return Optional.ofNullable(em.find(domainClass, id));
    }

    @Override
    public <S extends T> S save(S entity) {
        if (entityManager.contains(entity)) {
            return entityManager.merge(entity);
        } else {
            entityManager.persist(entity);
            return entity;
        }
    }
}

```

👉 Spring이 내부에서 **이 클래스의 프록시를 자동으로 만들어서 Bean 등록**.

---

### 4️⃣ 실행 흐름 (요약)

```
UserRepository → JpaRepository 인터페이스 상속
           ↓
Spring Data JPA가 런타임에 Proxy 구현체 생성
           ↓
SimpleJpaRepository 위임
           ↓
EntityManager 호출 → 실제 JPA 동작
           ↓
SQL 실행 → 결과 엔티티 반환

```

---

## Repository 계층 구조

| 인터페이스 | 주요 기능 |
| --- | --- |
| `Repository` | 마커 인터페이스 — 스프링이 저장소로 인식 |
| `CrudRepository` | 기본 CRUD 기능 (`save`, `findById`, `delete`) |
| `PagingAndSortingRepository` | 페이징/정렬 기능 (`findAll(Pageable)`) |
| `JpaRepository` | JPA 특화 기능 (`flush`, `saveAndFlush`) |
| `SimpleJpaRepository` | 실제 구현체 클래스 |

> JpaRepository는 추상 인터페이스이고
> 
> 
> 진짜 동작은 **SimpleJpaRepository** 가 담당.
> 

---

## Query 생성 방식 3가지

### ① 메서드 이름 기반 쿼리

```java
List<User> findByEmail(String email);
List<User> findByNameAndStatus(String name, String status);

```

→ 자동으로 JPQL 생성

→ `SELECT u FROM User u WHERE u.email = ?1`

---

### ② @Query 직접 지정

```java
@Query("SELECT u FROM User u WHERE u.status = 'ACTIVE'")
List<User> findActiveUsers();

```

→ 복잡한 쿼리도 JPQL로 직접 작성 가능

---

### ③ 네이티브 쿼리 사용

```java
@Query(value = "SELECT * FROM user WHERE email = :email", nativeQuery = true)
User findByEmailNative(@Param("email") String email);

```

→ DB SQL 그대로 사용 가능

---

## 트랜잭션과 영속성 컨텍스트 통합

Spring Data JPA는 `@Transactional`을 자동으로 관리합니다.

| 메서드 | 기본 트랜잭션 속성 |
| --- | --- |
| `save`, `delete`, `flush` | `@Transactional` (쓰기 트랜잭션) |
| `findById`, `findAll` | `@Transactional(readOnly = true)` |

> 따로 어노테이션을 붙이지 않아도
> 
> 
> 기본 CRUD 메서드는 트랜잭션 안에서 안전하게 동작합니다.
> 

---

## ueryDSL, Specification, Auditing

Spring Data JPA는 확장성도 뛰어납니다.

| 기능 | 설명 |
| --- | --- |
| **QueryDSL** | 타입 세이프 JPQL 빌더 (동적 쿼리) |
| **Specification** | JPA Criteria API 기반 동적 조건 조합 |
| **Auditing** | 생성일, 수정일 자동 기록 (`@CreatedDate`, `@LastModifiedDate`) |
|  |  |

---

## Spring Proxy와의 관계

Spring Data JPA의 Repository도 사실 “**프록시 객체**”입니다.

- 런타임 시점에 `UserRepository`의 프록시 구현체를 생성
- 실제 DB 동작은 내부의 `SimpleJpaRepository`로 위임

“Spring AOP 프록시”로 감싸서 기능을 주입하는 구조입니다.

(이건 **JPA의 Lazy Proxy**와는 완전히 다른 레벨의 프록시예요.)

---
