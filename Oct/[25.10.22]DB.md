# 📚DB 핵심 개념 정리(Index,  Full Text Index, Transaction)

## <mark> 1️⃣ Index </mark>

### 실행 계획 확인하기 - **EXPLAIN 명령어**

`EXPLAIN` 명령어는 **데이터베이스 쿼리의 실행 계획(Execution Plan)** 을 확인하기 위한 SQL 명령어.

**DB가 쿼리를 실제로 어떻게 처리할지(인덱스를 사용하는지, 테이블을 풀스캔하는지 등)** 를 보여줌.

---

## 1. 기본 개념

`EXPLAIN`은 SQL문 앞에 붙여서 사용합니다.

```sql
EXPLAIN SELECT * FROM users WHERE age > 30;

```

이 명령을 실행하면 **쿼리 실행 계획표**가 출력.

이는 DB 옵티마이저(Optimizer)가 쿼리를 실행할 때 **어떤 경로로 데이터를 찾을지**를 분석한 결과.

---

## 2. 주요 용도

| 목적 | 설명 |
| --- | --- |
| **성능 분석** | 쿼리가 느릴 때, 인덱스 사용 여부나 테이블 풀스캔 여부를 확인 |
| **인덱스 튜닝** | 어떤 인덱스가 사용되는지 확인하고, 필요시 새 인덱스 추가 |
| **조인 최적화** | 여러 테이블 조인 시 조인 순서 및 방식(Nested Loop, Hash Join 등)을 분석 |

---

## 3. 출력 컬럼 주요 항목 (MySQL 기준)

| 컬럼명 | 설명 |
| --- | --- |
| **id** | 쿼리 실행 순서 (여러 쿼리일 경우 식별자 역할) |
| **select_type** | SELECT의 유형 (SIMPLE, PRIMARY, SUBQUERY 등) |
| **table** | 액세스 중인 테이블 이름 |
| **type** | 조인 방식 (ALL, index, range, ref, eq_ref, const, system 등) — **성능 분석의 핵심** |
| **possible_keys** | 사용할 수 있는 인덱스 목록 |
| **key** | 실제 사용된 인덱스 |
| **rows** | 예상 스캔 행 수 (많을수록 느림)  |
| **filtered** | 조건절에 의해 필터링된 비율(%) |
| **Extra** | 추가 정보 (Using index, Using where, Using temporary 등) |

---

<aside>
💡

쿼리 결과  - type: 이 쿼리가 데이터를 어떻게 찾았는지를 나타냄.

ALL : 풀스캔 → 인덱스 활용 못하고 있는 상황

index: 풀 인덱스 스캔, 인덱스 전체를 훑음.

range : 인데스를 사용해서 특정 범위를 탐색  

ref : 인덱스를 사용해서 동등비교 

const, system : 결과를 한건으로 특정할 수 있을 때 (pk, unique)

Extra 추가 적인 정보 표시 

- Using where: WHERE 절 조건으로 데이터 필터링 했다는 이야기
- Using index: 커버링 인덱스가 사용 됐다는 의미. 쿼리에 필요한 모든 데이터가 인덱스에 포함되어 있어서 굳이 실제 테이블까지 가지 않고 인덱스에서만 정보 읽어서 처리했다.
- Using filesort: 인덱스 사용하지 못하고 별도의 메모리 공간이나 디스크 사용해서 데이터를 정렬했다는 의미. 좋지 않다. 성능 저하의 주범 중 하나다.
</aside>

<aside>
💡

커버링 인덱스(Covering Index)는 쿼리를 처리할 때 **테이블을 직접 읽지 않아도 인덱스만으로 필요한 데이터를 모두 가져올 수 있는** 인덱스.

→ 쿼리에 필요한 모든 정보가 이미 인덱스 페이지안에 다 들어 있기 떄문에 인덱스 페이지만 읽고 결과를 반환해서 성능이 좋다.

비클러스터 단점이 키로 찾는 건데 이걸로 성능 최적화 가능 

</aside>

## 4. 예시

```sql
EXPLAIN SELECT * FROM users WHERE email = 'abc@test.com';

```

| id | select_type | table | type | possible_keys | key | rows | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | SIMPLE | users | ref | idx_email | idx_email | 1 | Using where |

`key=idx_email` → 인덱스를 잘 활용 중

`rows=1` → 1건만 스캔

→ 매우 효율적인 쿼리

---

## 5. 비효율적인 경우

```sql
EXPLAIN SELECT * FROM users WHERE age > 30;

```

| id | select_type | table | type | possible_keys | key | rows | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | SIMPLE | users | ALL | NULL | NULL | 100000 | Using where |

`type=ALL` → **Full Table Scan** (전체 테이블 스캔)

→ 인덱스가 없거나 사용되지 않음

→ `age` 컬럼에 인덱스 추가 필요

---

## 6. 추가 명령어

- **`EXPLAIN ANALYZE` (MySQL 8.0+)**
    
    ```sql
    EXPLAIN ANALYZE SELECT * FROM users WHERE id = 10;
    
    ```
    
    → 실제 실행 후 **실행 시간, 실제 스캔된 행 수**까지 보여줌
    
    → 예측(`EXPLAIN`)보다 훨씬 정확한 성능 진단 가능
    
- **`EXPLAIN (FORMAT=JSON)`**
    
    ```sql
    EXPLAIN FORMAT=JSON SELECT * FROM users;
    
    ```
    
    → 복잡한 실행 계획을 **JSON 형태로 시각화/분석** 가능
    

---

<aside>
💡

## 인덱스를 활용해도 성능이 좋아지지 않는 이유

### **데이터 양이 너무 적을 때**

- 테이블에 **레코드가 몇 천 개 이하**라면
    
    인덱스 탐색 + 테이블 접근 오버헤드가 더 큼.
    
- DB는 “인덱스 거치지 말고 그냥 전체 스캔이 더 빠르다”고 판단할 수 있음.

> 💡 예: 100건짜리 테이블에서 SELECT * FROM users WHERE age=20
> 
> 
> ⇒ 인덱스보다 **Full Table Scan**이 더 빠름.
> 

---

### 캐싱

- 데이터베이스는 한 번 읽어온 데이터를 메모리에 캐싱함

> 💡 성능 정확하게 비교하려면 테스트 전에 캐시를 비워줘야함.
> 

### **선택도가 낮은(=중복이 많은) 컬럼일 때**

- 인덱스는 “데이터를 얼마나 잘 걸러낼 수 있느냐”가 중요함.
- 예를 들어 성별(`M/F`)처럼 **값 종류가 적은 컬럼**은 인덱스 의미가 거의 없음.

> 💡 WHERE gender = 'M' → 전체의 절반 이상이 남음 → 인덱스 효과 X
> 

---

### 3️⃣ **함수나 연산이 걸린 조건일 때**

- 인덱스 컬럼에 함수나 연산이 걸리면 인덱스를 사용하지 못함.

```sql
-- 인덱스 사용 안 됨
SELECT * FROM users WHERE YEAR(birth_date) = 2000;

```

> 💡 YEAR(birth_date) 대신 birth_date BETWEEN '2000-01-01' AND '2000-12-31'
> 
> 
> 로 바꿔야 인덱스 사용 가능.
> 

---

### 4️⃣ **LIKE 검색의 앞부분에 와일드카드가 있을 때**

- `%`가 문자열 **앞에** 있으면 인덱스가 무력화됩니다.

```sql
-- 인덱스 사용 불가
SELECT * FROM users WHERE name LIKE '%길동';
-- 인덱스 사용 가능
SELECT * FROM users WHERE name LIKE '홍%';

```

---

### 5️⃣ **OR 조건이 많거나, 복잡한 조건 조합일 때**

- 여러 조건이 혼합되면 옵티마이저가 인덱스보다 전체 스캔을 택할 수 있음.

```sql
SELECT * FROM users WHERE name='홍길동' OR age=20;

```

> OR 조건은 각각의 인덱스를 따로 탐색해야 하므로 비효율적일 수 있음.
> 

---

### 6️⃣ **인덱스는 읽기엔 빠르지만, 쓰기엔 느림**

- `INSERT`, `UPDATE`, `DELETE` 시 인덱스도 함께 갱신해야 함.
    
    인덱스가 많을수록 쓰기 작업 속도 저하.
    

> 💡 읽기 많은 시스템에는 유리하지만, 쓰기 많은 시스템에는 과도한 인덱스는 독이 됨.
> 

---

### 

</aside>

### 인덱스 생성 시 트레이드오프 정리

| 구분 | 장점 (Pros) | 단점 (Cons) |
| --- | --- | --- |
| **조회 성능** | `SELECT`, `WHERE`, `ORDER BY`, `JOIN` 속도 향상 | - |
| **쓰기 성능** | - | `INSERT`, `UPDATE`, `DELETE` 시 인덱스도 함께 갱신되어 **쓰기 느려짐** |
| **저장 공간** | - | 인덱스가 **추가 디스크 공간** 차지 (데이터 크기 ↑) |
| **유지 보수 비용** | - | 인덱스 구조 관리, 통계 갱신 등의 **관리 오버헤드 발생** |
| **복잡성** | - | 너무 많으면 옵티마이저가 **잘못된 인덱스 선택** 가능 |
| **데이터 변경 빈도** | 정적(조회 위주) 테이블에는 매우 유리 | 변경이 잦은 테이블은 비효율적 |
- 서비스에서 읽기 중심인지, 쓰기 중심(로그 수집 서버, 채팅 서비스)인지에 따라서 인덱스 전략이 달라진다.

### 복합 인덱스

## 개념 정의

> 복합 인덱스 = 여러 컬럼(column1, column2, …)을 묶어 하나의 인덱스로 만든 것
> 

예를 들어, 다음과 같이 인덱스를 생성할 수 있습니다:

```sql
CREATE INDEX idx_user_name_age ON users(name, age);

```

이 인덱스는 **(name → age)** 순으로 정렬된 인덱스를 생성합니다.

---

## 동작 원리: **왼쪽 우선(Leftmost Prefix Rule)**

복합 인덱스는 **왼쪽에서부터 순서대로만** 인덱스를 사용할 수 있습니다.

카디널리티가 높은 컬럼을 앞 순서에 둬야함. 

| 조건 | 인덱스 사용 가능 여부 | 설명 |
| --- | --- | --- |
| `WHERE name = '홍길동'` | 사용 | 첫 번째 컬럼 사용 |
| `WHERE name = '홍길동' AND age = 25` | 사용 (복합 인덱스 효과적) | 첫 번째 + 두 번째 컬럼 모두 사용 |
| `WHERE age = 25` | 사용 불가 | 첫 번째 컬럼(name)을 건너뛰면 인덱스 못 씀 |
| `WHERE name LIKE '홍%'` | 사용 가능 | 접두 일치라면 인덱스 사용 가능 |

> 💡 복합 인덱스는 왼쪽부터 차례로 조건이 걸려야 인덱스 효과를 발휘합니다.
> 

---

## 예시

### 인덱스 생성

```sql
CREATE INDEX idx_user_dept_salary ON employees(dept, salary);

```

### 쿼리별 인덱스 활용 여부

| 쿼리 | 인덱스 사용 | 설명 |
| --- | --- | --- |
| `WHERE dept='개발'` | ✅ | 첫 번째 컬럼 사용 |
| `WHERE dept='개발' AND salary > 5000` | ✅ | 첫 번째+두 번째 사용 |
| `WHERE salary > 5000` | ❌ | 첫 번째 컬럼이 빠짐 |
| `WHERE salary > 5000 AND dept='개발'` | ✅ (조건 순서는 상관없음, 옵티마이저가 최적화) |  |

---

## 장점

| 장점 | 설명 |
| --- | --- |
| **여러 조건을 동시에 빠르게 검색** | 두 개 이상 컬럼을 한 번에 필터링 |
| **정렬 효율 향상** | `ORDER BY`에서 인덱스 컬럼 순서와 일치하면 추가 정렬 불필요 |
| **쿼리 성능 향상** | 다중 조건(`WHERE col1=?, col2=?`)에 유리 |

---

## 주의점

| 주의사항 | 설명 |
| --- | --- |
| **컬럼 순서 중요** | 왼쪽부터 사용해야 인덱스 적용됨 |
| **불필요하게 많은 컬럼 금지** | 인덱스 크기 커지고 쓰기 성능 저하 |
| **중간 컬럼만 조건 걸면 무효** | 왼쪽 규칙 깨짐 (`col2`만 검색 불가) |

---

## <mark> 2️⃣ Full Text Index </mark>

## 정의

> 풀 텍스트 인덱스(Full-Text Index) 는
> 
> 
> **긴 문장이나 문서(Text 컬럼)** 안에서 **단어 단위 검색**을 빠르게 하기 위한 인덱스입니다.
> 

일반 인덱스는 `=`나 `<`, `>` 같은 **정확한 값 비교**에 최적화되어 있지만,

**Full-Text 인덱스는 자연어 검색**(단어 포함 여부, 유사도 검색 등)에 특화되어 있습니다.

---

## 사용 예시 (MySQL 기준)

```sql
CREATE TABLE articles (
  id INT AUTO_INCREMENT PRIMARY KEY,
  title VARCHAR(255),
  content TEXT,
  FULLTEXT (title, content)   -- 풀텍스트 인덱스 생성
);

```

이제 아래와 같은 쿼리로 **자연어 검색**을 할 수 있습니다.

```sql
SELECT *
FROM articles
WHERE MATCH(title, content)
AGAINST ('인공지능 교통 제어 시스템');

```

---

## 동작 원리

- 텍스트를 **단어 단위(token)** 로 쪼개서 인덱스에 저장합니다.
- 쿼리 시, 해당 단어가 등장한 문서를 빠르게 찾아냅니다.
- 단순 포함 여부(`LIKE '%단어%'`)보다 훨씬 빠름.

> 💡 예를 들어 "강화학습 기반 교통 제어" 라는 문장은
> 
> 
> `["강화학습", "기반", "교통", "제어"]` 로 분리되어 인덱싱됨.
> 

---

## 검색 모드 (MySQL 기준)

| 모드 | 설명 |
| --- | --- |
| **NATURAL LANGUAGE MODE** | 단어의 중요도(TF-IDF) 기반으로 자동 점수 계산 |
| **BOOLEAN MODE** | `+`, `-`, `*`, `>` 같은 연산자를 써서 세밀한 조건 제어 가능 |
| **WITH QUERY EXPANSION** | 비슷한 단어까지 확장해서 검색 (유사어 검색) |

**예시**

```sql
SELECT * FROM articles
WHERE MATCH(content)
AGAINST ('+강화학습 -교통' IN BOOLEAN MODE);

```

→ “강화학습”은 반드시 포함, “교통”은 제외

---

## 장점과 단점

| 구분 | 내용 |
| --- | --- |
| **장점** | 긴 텍스트에서도 빠른 검색, 자연어 분석 가능, 유사도 순 정렬 |
| **단점** | 인덱스 크기 큼, 실시간 업데이트 비용 높음, 불용어(stop word) 무시됨 |
| 한계 | - 정교한 언어 처리의 부재
- 동의어 설정 불가능(노트북, 랩탑 같은 의미로 처리 불가능)
- 복잡한 랭킹 모델의 한계(최신글에 더 높은 점수)
- 검색 특래픽 높아지면 DB 자체가 부하가 오고 검색 기능 떄문에 DB 전체가 느려짐.  → 검색 엔진(Elastic, Search 등)  |

---

## LIKE 비교와 차이

| 방식 | 설명 | 성능 |
| --- | --- | --- |
| `LIKE '%단어%'` | 부분 문자열 탐색 (인덱스 거의 미사용) | 느림 |
| `MATCH() AGAINST()` | 단어 단위 검색 (풀텍스트 인덱스 사용) | 빠름 |

<aside>
💡

**LIKE 검색의 문제(안티패턴)**

- LIKE ‘검색어%’
    - 그나마 괜찮다. 비트리 인덱스 있으면 인덱스 활용
- LIKE ‘%검색어’ or LIKE ‘%검색어%’
    - 검색어가 어디에 위치할지 모르기 때문
    - 데이터베이스 인덱스 포기하고 모든 데이터하나씩 비교
- 설명

## LIKE 검색의 기본 동작

`LIKE` 연산자는 문자열 패턴을 비교할 때 `%`(와일드카드)를 사용합니다.

```sql
SELECT * FROM users WHERE name LIKE '홍%';
SELECT * FROM users WHERE name LIKE '%길동';
SELECT * FROM users WHERE name LIKE '%길%동%';

```

- `%`: 아무 문자열이든 0개 이상
- `_`: 정확히 한 글자

즉, 문자열의 **앞/뒤/중간**에 어떤 글자가 올지 모를 때 사용하는 문법이죠.

---

## 인덱스와의 관계

DB의 일반적인 인덱스(B-Tree 인덱스)는 **정렬된 상태로 탐색**합니다.

즉, “**앞부분(prefix)**”이 어떤 값인지를 기준으로 탐색합니다.

예를 들어 이름 인덱스가 다음과 같이 정렬되어 있다고 해봅시다 👇

```
강감찬
강길동
고길동
김가영
김길동
박길동

```

이제 `LIKE '김%'`을 실행하면?

→ `"김"`으로 시작하는 구간만 **빠르게 탐색 가능**합니다.

즉, **인덱스가 정렬된 순서를 이용할 수 있음**.

---

## 그런데 `LIKE '%검색어%'`는?

문제는 `%`가 **앞에 올 때**입니다.

```sql
SELECT * FROM users WHERE name LIKE '%길동';

```

이 경우 DB는 `"길동"`이 문자열의 **어느 위치에 있는지 알 수 없음** →

즉, 인덱스의 정렬 순서를 전혀 활용할 수 없습니다.

그래서 DB는 다음과 같이 동작합니다 👇

> “전체 데이터를 한 줄씩 읽어서 name 컬럼에 ‘길동’이 포함되어 있나 확인”
> 

**Full Table Scan (테이블 전체 탐색)** 발생.

데이터가 많을수록 **성능 급격히 저하**.

---

## 예시로 비교

| 쿼리 | 인덱스 사용 | 설명 |
| --- | --- | --- |
| `WHERE name LIKE '김%'` | 사용 | `"김"`으로 시작하는 구간만 탐색 |
| `WHERE name LIKE '%김%'` | 미사용 | `"김"`이 어디에 있을지 몰라 전체 탐색 |
| `WHERE name LIKE '%김'` | 미사용 | 뒤쪽 일치도 인덱스 탐색 불가능 |

---

## 성능 차이 체감 예시

예를 들어 `users` 테이블에 100만 명이 있다고 할 때:

| 쿼리 | 예상 스캔 행 수 | 실행 속도 |
| --- | --- | --- |
| `LIKE '김%'` | 약 5,000행 | 매우 빠름 |
| `LIKE '%김%'` | 약 1,000,000행 | 매우 느림 |

---

## 해결 방안

| 방법 | 설명 |
| --- | --- |
| **풀텍스트 인덱스 (Full-Text Index)** | 단어 단위로 인덱싱 → `MATCH() AGAINST()` 사용 |
| **역인덱스(Reverse Index)** | 문자열을 거꾸로 저장해 뒤쪽 일치 탐색 가능 (`LIKE '%검색어'`) |
| **전문 검색 엔진 도입** | Elasticsearch, Solr 등으로 텍스트 검색 기능 분리 |
| **n-gram 인덱스** | 문자열을 일정 단위로 쪼개어 검색 (`MySQL 8+`, `ngram parser`) |

---

</aside>

---

## <mark> 3️⃣ Transaction </mark> 

---

## 정의

> 트랜잭션(Transaction) 은 하나 이상의 SQL 연산을 묶어서 전부 성공하거나, 전부 실패하게 하는 논리적 단위(Logical Unit of Work) 입니다. + 절대로 쪼개져서는 안되는 논리적인 작업의 최소 단위
> 

👉 쉽게 말하면

> “은행 송금처럼 둘 다 성공하거나, 둘 다 실패해야 하는 작업 묶음”
> 

---

## 예시: 은행 송금

```sql
-- 송금 과정
1. A 계좌에서 10만원 출금
2. B 계좌에 10만원 입금

```

이 두 쿼리 중 하나라도 실패하면 안 되겠죠?

- A의 잔고는 줄었는데, B의 입금이 실패하면 **데이터 불일치**
- 그래서 두 쿼리를 하나의 트랜잭션으로 묶어야 합니다.

```sql
START TRANSACTION;

UPDATE account SET balance = balance - 100000 WHERE name = 'A';
UPDATE account SET balance = balance + 100000 WHERE name = 'B';

COMMIT;   -- 둘 다 성공 시 확정
-- ROLLBACK; 중간에 오류 시 원상복구

```

---

## 트랜잭션의 4대 특징 — **ACID 원칙**

| 항목 | 의미 | 설명 |
| --- | --- | --- |
| **A (Atomicity)** | 원자성 | 모든 작업이 **전부 수행되거나, 전혀 수행되지 않음** |
| **C (Consistency)** | 일관성 | 트랜잭션 전후로 **데이터의 제약 조건이 항상 유지** |
| **I (Isolation)** | 독립성 | 여러 트랜잭션이 동시에 실행돼도 **서로 간섭하지 않음** |
| **D (Durability)** | 지속성 | 커밋된 데이터는 **시스템 장애 후에도 유지됨** |

<aside>
💡

**Isolatiom** - isolation level 옵션을 제공해서 개발자 조정 할 수 있다 // 트레이드 오프

**Durability -** 지속성을 유지하기 위해 변경 내용을 로그로 기록 

</aside>

---

## 트랜잭션 명령어 요약

| 명령어 | 설명 |
| --- | --- |
| `START TRANSACTION` 또는 `BEGIN` | 트랜잭션 시작 |
| `COMMIT` | 모든 작업을 확정 (DB에 반영) |
| `ROLLBACK` | 오류 발생 시 되돌리기 |
| `SAVEPOINT 이름` | 되돌릴 수 있는 중간 지점 설정 |
| `ROLLBACK TO 이름` | 특정 SAVEPOINT까지 되돌리기 |

---

## 트랜잭션의 필요성

| 이유 | 설명 |
| --- | --- |
| **데이터 무결성 보장** | 중간 실패로 인한 불일치 방지 |
| **동시성 제어** | 여러 사용자가 동시에 DB를 조작할 때 충돌 방지 |
| **복구 가능성** | 시스템 장애 시 ROLLBACK으로 복원 가능 |

---

## 트랜잭션의 격리 수준 (Isolation Level)

<img width="1114" height="622" alt="image" src="https://github.com/user-attachments/assets/352b1c20-10f3-4b0f-95ef-df692149cdf8" />




> 💡 MySQL의 기본 격리 수준은 REPEATABLE READ
> 
- 격리 수준이 올라가면, 완벽한 격리는 성능 저하를 유발. 4가지 격리 수준을 정의하고 개발자가 선택.
- 격리 수준이 낮으면 낮을수록 동시성은 높아진다(성능 향상) 데이터 부정합 문제 발생할 가능성이 크다.
- 격리 수준이 높으면 높을수록 정합성은 완벽해지지만 동시성이 낮아진다.(성능 저하)

---
