# 📚 FE - TanStack Query 정리

---
## <mark> TanStack Query </mark>

### 1) TanStack Query란

* **서버 상태(Server State)** 를 클라이언트(React/Next.js 등)에서 **가져오고, 캐싱하고, 동기화하고, 갱신**하기 위한 라이브러리.
* “전역 상태관리(Redux/Zustand) 대체”가 아니라, **서버에서 온 비동기 데이터 관리 전용 도구**.

---

### 2) 왜 필요한가? (서버 상태의 본질)

서버 상태는 다음 특성이 있어 직접 관리가 번거롭다.

* 서버가 진짜 원본(source of truth)이라 **언제든 바뀔 수 있음**
* **비동기**(네트워크 지연/실패/재시도)
* 여러 컴포넌트/페이지에서 같은 데이터를 쓰면 **중복 요청**과 **불일치**가 생김
* 데이터가 “언제 오래됐는지(stale)” 판단이 필요함

TanStack Query는 이런 문제를 표준화된 방식으로 처리한다.

---

### 3) 핵심 구성 요소

* **QueryClient**: 캐시/요청/옵션/상태를 총괄 관리하는 중앙 관리자
* **Query Cache**: query 결과를 저장하는 캐시(메모리)
* **Mutation Cache**: mutation 실행 상태를 저장/관리
* **QueryKey**: 특정 서버 데이터의 “이름/식별자” (캐시의 키)

---

### 4) Query란? (읽기 / 조회)

**정의**

* 서버에서 데이터를 **가져오는(Read)** 작업을 표현하는 단위.
* 일반적으로 **GET** 요청에 해당.

**구성**

* `queryKey`: 이 데이터는 무엇인가? (캐시 식별자)
* `queryFn`: 이 데이터를 어떻게 가져오는가? (fetch 함수)

**동작 개념**

* `useQuery`가 실행되면:

  1. 동일 `queryKey` 캐시가 있으면 우선 캐시를 반환
  2. 캐시가 없거나 stale이면 네트워크 요청 실행
  3. 성공하면 캐시에 저장하고 구독 중인 컴포넌트들을 갱신

**Query 상태**

* `isPending`(로딩), `isError`(실패), `data`(성공 데이터), `error` 등으로 표준 제공

---

### 5) Mutation이란? (쓰기 / 변경)

**정의**

* 서버 데이터를 **변경(Write)** 하는 작업을 표현하는 단위.
* 일반적으로 **POST/PUT/PATCH/DELETE** 요청에 해당.

**특징**

* Query처럼 자동으로 실행되지 않으며 보통 **사용자 액션(버튼/폼)** 으로 트리거됨.
* 성공/실패 후에 **후처리(캐시 갱신/롤백/토스트)** 가 핵심.

**Mutation 상태**

* `isPending`, `isSuccess`, `isError`, `data`, `error` 등 표준 제공

---

### 6) Query vs Mutation 차이

* **Query**: 서버 상태를 “가져와서” 캐시에 저장하고 공유 (읽기)
* **Mutation**: 서버 상태를 “바꾸는 이벤트”를 실행 (쓰기)
* **관계 핵심**: mutation 성공 후 기존 query 캐시는 **오래된(stale) 데이터가 될 수 있음**
  → 그래서 보통 **invalidate/refetch 또는 캐시 직접 업데이트**가 필요

---

### 7) 캐시(Cache)와 동기화 전략

TanStack Query는 “서버 데이터 스냅샷”을 캐시에 저장하고 이를 중심으로 화면을 구성한다.

**중요 동작**

* **중복 요청 제거(deduping)**: 같은 `queryKey`에 대해 동시에 여러 컴포넌트가 요청해도 **요청 1번만** 보내고 결과 공유
* **공유**: 같은 `queryKey`를 쓰는 컴포넌트는 **같은 캐시 데이터**를 공유
* **stale/fresh 관리**: 데이터가 “얼마나 신선한지”를 기준으로 재요청 여부를 결정

---

### 8) Refetch가 필요한 이유와 기준

서버 상태는 바뀔 수 있으므로 “언제 다시 가져올지” 규칙이 필요하다.

TanStack Query는 이를 옵션으로 표준 제공한다.

* `staleTime`: 이 시간 동안은 fresh로 취급(재요청 덜 함)
* `gcTime`(또는 cacheTime): 사용 안 하는 캐시를 언제 제거할지
* `refetchOnWindowFocus`: 탭 복귀 시 재요청 여부
* `refetchOnReconnect`: 네트워크 복구 시 재요청 여부
* `refetchInterval`: 주기적 폴링(필요 시)

---

### 9) Mutation 이후 화면을 최신화하는 방법 2가지

Mutation이 성공해도 Query 캐시가 자동으로 바뀌지는 않으므로 보통 아래 중 하나를 한다.

1. **invalidateQueries**

* 해당 queryKey를 **stale 처리**해서 다음 기회에 다시 fetch하도록 유도(또는 즉시 refetch)
* 정합성 측면에서 가장 안전하고 흔한 방식

2. **setQueryData (캐시 직접 수정)**

* 서버 응답값을 기반으로 캐시를 즉시 업데이트
* 빠른 UX 가능하지만 캐시 정합성을 직접 책임져야 함

---

### 10) Optimistic Update(낙관적 업데이트)

서버 응답을 기다리지 않고 UI를 먼저 업데이트하는 패턴.

* `onMutate`: 캐시를 임시로 먼저 변경(스냅샷 저장)
* `onError`: 실패 시 스냅샷으로 롤백
* `onSuccess/onSettled`: 최종 동기화(invalidate 또는 응답 반영)

---

### 11) TanStack Query가 “직접 구현하면 만들게 되는 것들”을 제공하는 항목

* **캐시 저장소(Query Cache)**
* **중복 요청 방지/병합(deduping)**
* **refetch 정책(언제 다시 가져올지)**
* **로딩/에러/성공 상태 표준화**
* **실패 재시도(retry)**
* **화면/컴포넌트 간 데이터 공유**
* **mutation 후 캐시 무효화/갱신 패턴**
* **(옵션) optimistic update/롤백**

---

### 12) Next.js와의 관계(충돌 여부)

* Next.js의 서버 패칭/SSR/ISR은 “초기 렌더/서버 측 최적화” 레이어.
* TanStack Query는 “클라이언트 런타임에서 서버 상태 캐시/동기화” 레이어.
* 역할이 달라 **충돌이 아니라 보완 관계**로 함께 사용 가능.

