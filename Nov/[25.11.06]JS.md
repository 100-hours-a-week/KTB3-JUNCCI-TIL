# 📚 JS 핵심 개념 정리(callBack)

---
# <mark> callBack </mark>

## 비동기적 코드 결과 처리 방법

---

자바스크립트에서 **비동기(Asynchronous)** 혹은 **논블로킹(Non-blocking)** 코드의 결과를 처리하는 방법은 세 가지가 있습니다.

1. CallBack
2. Promise
3. Async / Await

이 중 **콜백 함수(callback function)** 는 가장 기초적이면서도, 비동기 처리의 출발점이 되는 개념입니다.

---

## 콜백 함수의 정의

---

> 콜백 함수(Callback Function) 는 다른 함수의 인자로 전달되어, 그 함수의 내부에서 특정 시점에 실행되는 함수입니다.
> 
- **동기적 콜백(Synchronous Callback)** 과
    
    **비동기적 콜백(Asynchronous Callback)** 으로 구분됩니다.
    
- 전통적인 **비동기 결과 처리 방식**이며,
    
    “함수를 인자로 넘겨 실행 권한을 위임하는 구조”입니다.
    
- 단, **callback ≠ 비동기 함수**
    
    → 콜백은 ‘특정 시점에 실행되는 함수’일 뿐이며, 항상 비동기라는 뜻은 아닙니다.
    

---

### 동기적 콜백

즉시 실행되는 형태의 콜백.

대표적으로 배열 메서드에서 사용됩니다.

```jsx
const names = ['startupcode', 'adapterz', 'tetricodde'];

function syncCallback(item) {
  console.log(item);
}

names.map(syncCallback); // 순차적으로 즉시 출력

```

---

### 비동기적 콜백

일정 시간이 지나거나 이벤트가 발생한 뒤 실행되는 콜백.

```jsx
function asyncCallback() {
  console.log('Callback');
}

setInterval(asyncCallback, 1000);
// 1초마다 "Callback" 출력

```

또는 다음과 같이 활용할 수도 있습니다:

```jsx
const names = ['startupcode', 'adapterz', 'tetricodde'];

function asyncCallback(item) {
  console.log(item);
}

names.forEach((item, index) => {
  setTimeout(() => asyncCallback(item), (index + 1) * 1000);
});
// 1초 간격으로 각 항목 출력

```

---

## 사용 이유

---

| 이유 | 설명 |
| --- | --- |
| **동기 코드의 한계** | 동기 코드는 이전 작업이 끝나기 전에는 다음 코드로 넘어가지 못해, 비동기 작업(예: 서버 요청)에서 데이터 불완전 문제가 발생할 수 있습니다. |
| **블로킹 문제 해결** | 하나의 작업이 완료될 때까지 전체 프로그램 실행이 멈추는 ‘블로킹’을 방지하고, UI 반응성을 높이기 위해 콜백이 사용됩니다. |

---

## 사용 방법

---

콜백 함수는 **비동기 작업의 결과를 처리할 함수를 인자로 전달**하는 방식으로 사용됩니다.

```jsx
function asyncAdd(a, b, callback) {
  setTimeout(() => {
    const sum = a + b;
    callback(sum); // 결과를 콜백으로 전달
  }, 1000);
}

asyncAdd(5, 7, sum => {
  console.log(`Async Sum: ${sum}`); // Async Sum: 12
});

```

> 자바스크립트는 함수가 일급 객체(First-Class Object) 이므로,
> 
> 
> 함수를 변수나 인자로 자유롭게 전달할 수 있습니다.
> 
> 이 특성 덕분에 콜백 패턴이 가능해집니다.
> 

 콜백 패턴을 남용하면 **Callback Hell(콜백 지옥)** 이 발생할 수 있습니다.

---

### setTimeout 예시

```jsx
function sayHello(name) {
  console.log(`Hello, ${name}!`);
}

// 2초 뒤에 'Alice' 인자로 sayHello 실행
setTimeout(sayHello, 2000, 'Alice');

```

---

## 콜백 함수의 종류

---

### 1️⃣ 배열 메서드와 콜백 함수

( `map()`, `filter()`, `reduce()`, `forEach()` 등 )

```jsx
const numbers = [1, 2, 3, 4, 5];
const addFive = numbers.map(num => num + 5);
console.log(addFive); // [6, 7, 8, 9, 10]

```

| 메서드 | 설명 |
| --- | --- |
| `map()` | 각 요소를 변환한 새 배열을 반환 |
| `filter()` | 조건을 만족하는 요소만 새 배열로 반환 |
| `reduce()` | 배열 전체를 하나의 값으로 축약 |
| `forEach()` | 단순 반복 처리 (반환값 없음) |

---

### 2️⃣ 함수를 반환하는 함수 (고차 함수)

```jsx
function createAdder(x) {
  return function(y) {
    return x + y;
  };
}

const addTen = createAdder(10);
console.log(addTen(5)); // 15

```

---

### 3️⃣ 함수 컴포지션(Function Composition)

두 개 이상의 함수를 조합하여 새로운 기능을 만드는 패턴.

```jsx
function compose(f, g) {
  return function(x) {
    return f(g(x));
  };
}

const addTwo = x => x + 2;
const addThree = x => x + 3;
const addFive = compose(addThree, addTwo);

console.log(addFive(10)); // 15

```

---

## 알아두면 좋은 개념

---

### 콜백 지옥(Callback Hell) / 운명의 피라미드 (Pyramid of Doom)

비동기 처리를 위해 콜백을 과도하게 중첩할 경우 가독성이 떨어지고, 유지보수가 어려워지는 현상입니다.

```jsx
fetchData(data => {
  parseData(data, parsed => {
    filterData(parsed, filtered => {
      sortData(filtered, sorted => {
        console.log(sorted);
      });
    });
  });
});

```

- 실행 순서: fetchData → parseData → filterData → sortData → console.log
- 문제점: 코드의 **가독성 저하**, **유지보수 어려움**

> 이러한 문제를 해결하기 위해 Promise 와 Async/Await 가 등장했습니다.
> 

---
