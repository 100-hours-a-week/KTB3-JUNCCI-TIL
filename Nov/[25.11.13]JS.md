# 📚 JS 핵심 개념 정리(Prototype)

---
## <mark> 프로토타입(Prototype) </mark>

JavaScript는 **클래스 기반 언어가 아니라, 프로토타입 기반 언어**입니다.

객체가 다른 객체를 **직접 상속**받는 구조를 가지고 있습니다.

- 클래스나 객체의 **내용 복사 없이도 상속**을 구현할 수 있음
- 모든 객체는 내부적으로 **`[[Prototype]]`** (또는 `__proto__`)이라는 숨겨진 속성을 가짐
- 이 속성은 **다른 객체(프로토타입 객체)** 를 참조하며,
    
    이 연결 관계를 **프로토타입 체인(prototype chain)** 이라고 부름
    

---

## 기본 예시

```jsx
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log(`Hi! I'm ${this.name}`);
};

const user = new Person('Alice');
user.sayHello(); // "Hi! I'm Alice"

```

### 설명

- `Person`은 **생성자 함수**입니다.
- `Person.prototype` 객체에는 `sayHello` 메서드가 정의되어 있습니다.
- `user` 객체는 `Person`의 인스턴스이며, 내부적으로
    
    `user.__proto__ === Person.prototype` 을 만족합니다.
    
- 따라서 `user`가 직접 `sayHello`를 가지지 않아도
    
    `Person.prototype`을 통해 해당 메서드를 사용할 수 있습니다.
    

---

## 프로토타입 체인 (Prototype Chain)

객체에서 속성이나 메서드를 찾는 과정은 다음과 같습니다:

1. **객체 자신**에게 해당 프로퍼티가 있는지 확인
2. 없으면 **`[[Prototype]]` (`__proto__`)을 따라 상위 객체 탐색**
3. 최종적으로 `Object.prototype`까지 도달
4. 그래도 없으면 `undefined` 반환

```jsx
console.log(user.toString());
// user에는 없지만, Object.prototype.toString을 찾아 실행

```

➡️ 이렇게 상위 객체를 따라가며 탐색하는 과정을

**Prototype Chain (프로토타입 체인)** 이라고 부릅니다.

---

## 클래스 문법과 프로토타입의 관계

ES6의 `class` 문법은 **새로운 개념이 아니라 문법적 설탕(syntactic sugar)** 입니다.

내부적으로는 여전히 **프로토타입 기반 상속**을 사용합니다.

```jsx
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log(`Hi! I'm ${this.name}`);
  }
}

const user = new Person('Bob');
user.sayHello(); // "Hi! I'm Bob"

```

위 코드는 사실 아래 코드와 **기능적으로 동일**합니다 👇

```jsx
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log(`Hi! I'm ${this.name}`);
};

```

---

## 클래스 상속과 `super()`의 역할

`class` 문법에서는 `extends`와 `super()`을 사용하여 상속을 구현합니다.

하지만 이 또한 **프로토타입 체인 위에서 동작**합니다.

```jsx
class Car {
  constructor(model) {
    this.model = model;
  }

  drive() {
    console.log(`${this.model} is driving`);
  }
}

class Bus extends Car {
  constructor(model) {
    super(model);
    // 자식 클래스의 생성자에서는 this를 사용하기 전에 반드시 super()를 호출해야 함
    // super()는 부모 클래스의 생성자를 호출하여 부모로부터 속성을 초기화함
    this.speedLimit = 90;
  }

  applySpeedLimit() {
    console.log(`${this.model} has a speed limit of ${this.speedLimit} km/h`);
  }
}

const myBus = new Bus('Bus I');
myBus.drive();          // Bus I is driving
myBus.applySpeedLimit(); // Bus I has a speed limit of 90 km/h

```

> 정리
> 
> - `extends` → 부모 클래스의 프로토타입을 상속받음
> - `super()` → 부모 생성자 호출 (필수, `this` 사용 전에!)
> - 내부적으로는 여전히 `Bus.prototype.__proto__ === Car.prototype`

---

## 핵심 개념 요약표

| 개념 | 설명 |
| --- | --- |
| **prototype** | 생성자 함수가 가지는 프로퍼티 (인스턴스들이 공유하는 공간) |
| **proto** | 인스턴스가 자신의 프로토타입 객체를 가리키는 참조 |
| **프로토타입 체인** | 객체가 상속받은 프로퍼티를 탐색하는 연결 구조 |
| **Object.prototype** | 모든 객체의 최상위 프로토타입 |
| **super()** | 부모 생성자를 호출하는 키워드 (자식 생성자에서 `this`보다 먼저 실행해야 함) |

---

클래스 관려 추가 자료

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes
