# 📚 JS 핵심 개념 정리(Execution Context/ Scope/ Closure)

---
# <mark> 실행 컨텍스트 (Execution Context) </mark>

## 정의

**실행 컨텍스트**는 자바스크립트 코드가 실행될 때 **코드를 평가하고 관리하기 위한 실행 환경 객체**입니다.

**“코드 한 덩어리(전역, 함수 등)가 실행될 때 필요한 모든 정보를 담은 공간”** 이라고 할 수 있습니다.

이 안에는 변수, 함수, this, 스코프 체인 등 실행에 필요한 데이터가 모두 저장됩니다.

---

## 작동 원리

자바스크립트 엔진은 실행될 때 **“실행 컨텍스트 스택(Call Stack)”** 을 사용합니다.

- **전역 코드**가 실행되면 전역 실행 컨텍스트가 생성되어 스택에 쌓임
- **함수가 호출**될 때마다 새로운 실행 컨텍스트가 만들어져 스택의 맨 위에 올라감
- **함수가 종료**되면 해당 컨텍스트는 스택에서 제거됨

→ 따라서 JS는 **단일 스레드(single-thread)** 로, 스택의 맨 위 컨텍스트 하나만 실행합니다.

---

## 실행 컨텍스트의 구성요소

| 구성 요소 | 역할 |
| --- | --- |
| **Variable Environment** | `var` 변수, 함수 선언 저장 (호이스팅) |
| **Lexical Environment** | `let`, `const` 변수, 외부 스코프 참조 (스코프 체인 구성) |
| **This Binding** | 현재 실행 중인 함수에서 `this`가 참조할 객체 |

---

## 예시

```jsx
var a = 1;
function foo() {
  var b = 2;
  function bar() {
    var c = 3;
    console.log(a, b, c);
  }
  bar();
}
foo();

```

실행 흐름:

1. **전역 컨텍스트 생성** → a, foo 등록
2. **foo() 호출** → 새로운 컨텍스트 생성 (b, bar 등록)
3. **bar() 호출** → 또 다른 컨텍스트 생성 (c 등록)
4. **bar 종료 → foo 종료 → 전역만 남음**

이처럼 **스택 구조**로 관리되며, 스코프 체인을 통해 변수를 찾아나갑니다.

---
## 특징 정리

- 자바스크립트의 **실행 흐름 제어의 핵심 단위**
- **호이스팅(hoisting)** 은 실행 컨텍스트 생성 단계에서 발생
- **스코프 체인**과 **클로저**의 근본적인 기반이 됨
- **Call Stack** 에 쌓였다가 함수 종료 시 제거됨

---
# <mark> 스코프 (Scope) </mark>

## 정의

**스코프(Scope)** 는 “**변수나 함수가 접근할 수 있는 범위(유효 범위)**”를 의미.

어떤 코드에서 어떤 식별자(변수, 함수 이름 등)를 사용할 수 있는지를 결정하는 **규칙**.

자바스크립트에서는 **렉시컬 스코프(lexical scope)** 방식을 사용합니다 —

**함수가 정의된 위치**에 따라 접근 가능한 범위가 정해집니다 (호출 위치가 아님).

---

## 작동 원리

- 프로그램이 실행되면, 각 코드 블록이나 함수는 자신만의 “스코프”를 형성합니다.
- 변수를 사용할 때, JS 엔진은 **현재 스코프 → 상위 스코프 → 전역 스코프** 순으로 탐색합니다.
    
    이를 **스코프 체인(Scope Chain)** 이라고 합니다.
    
- 스코프는 중첩 구조를 이루며, 내부 스코프에서 외부 스코프의 변수에 접근할 수 있지만
    
    외부 스코프에서는 내부 스코프의 변수에 접근할 수 없습니다.
    

---

## 예시

```jsx
let x = 10; // 전역 스코프

function outer() {
  let y = 20; // outer의 지역 스코프

  function inner() {
    let z = 30; // inner의 지역 스코프
    console.log(x, y, z); // 10, 20, 30
  }

  inner();
  // console.log(z); // Error! z는 inner 스코프 안에만 존재
}

outer();

```

---

## 특징 정리

- **전역 스코프 (Global Scope)** : 프로그램 전체에서 접근 가능
- **함수 스코프 (Function Scope)** : 함수 내부에서만 유효 (var 변수)
- **블록 스코프 (Block Scope)** : `{}` 내에서만 유효 (let, const)
- **렉시컬 스코프 (Lexical Scope)** : 함수가 정의된 위치에 따라 스코프 결정

---

# <mark> 클로저 (Closure) <mark/>

## 정의

**클로저(Closure)** 는

“**함수가 자신이 선언될 때의 스코프(렉시컬 환경)를 기억하고**,

그 함수가 실행이 끝난 뒤에도 그 환경에 접근할 수 있는 현상”을 의미합니다.

**내부 함수가 외부 함수의 변수를 계속 참조할 수 있는 것**이 클로저입니다.

---

## 작동 원리

- 함수가 실행될 때마다 실행 컨텍스트가 만들어지고, 해당 함수의 **렉시컬 환경**이 함께 생성됩니다.
- 내부 함수가 외부 함수의 변수를 참조하면,
    
    외부 함수 실행이 끝난 후에도 **그 렉시컬 환경이 메모리에 남습니다.**
    
- 이로 인해 내부 함수가 외부 변수를 “기억”하게 됩니다.

---

## 예시

```jsx
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  }
}

const counter = outer();
counter(); // 1
counter(); // 2
counter(); // 3

```

- `outer()` 실행이 끝나도 `count`는 메모리에 남아 있음
- `inner()` 함수가 `outer`의 스코프(렉시컬 환경)를 기억하고 있기 때문
- 이렇게 외부 변수를 캡처(capture)한 함수가 **클로저 함수**

---

## 특징 정리

- 외부 함수의 변수를 “보존”할 수 있음 → **데이터 은닉**, **상태 유지** 가능
- 함수형 프로그래밍 패턴, 모듈 패턴 등에 자주 사용됨
- 하지만 남용 시 **메모리 누수 위험** 존재 (참조가 끊기지 않으면 GC 불가)

---

# 세 개념의 연결

| 개념 | 시점 | 역할 | 핵심 키워드 |
| --- | --- | --- | --- |
| **스코프** | 코드 작성 시 | 변수의 유효 범위 정의 | 렉시컬 스코프, 스코프 체인 |
| **실행 컨텍스트** | 코드 실행 시 | 실행 환경과 상태 관리 | Call Stack, Lexical Environment |
| **클로저** | 함수 실행 이후 | 스코프의 유지 및 기억 | 환경 캡처, 상태 유지 |

---

# 전체 흐름 한눈에 보기

1️⃣ **코드를 작성**하면 렉시컬 스코프(범위 규칙)가 결정

2️⃣ **코드를 실행**하면 실행 컨텍스트가 생성되어 그 스코프를 실제로 관리

3️⃣ **함수 내부에서 외부 스코프를 참조**하면, 실행 후에도 해당 환경이 메모리에 남아 **클로저**가 됨
