# 📚 React 핵심 개념 정리(Props Drilling)

---

# <mark> Props Drilling </mark>
**프롭스 드릴링**은 상위 컴포넌트의 데이터나 함수를 **실제로는 필요하지도 않은 중간 컴포넌트들**을 거쳐서,

깊숙한 하위 컴포넌트까지 `props`로 계속 넘겨야 하는 상황을 말한다.

```tsx
// App -> Layout -> Content -> VeryDeepComponent 로 계속 전달
<App>
  <Layout user={user} onLogout={onLogout}>
    <Content user={user} onLogout={onLogout}>
      <VeryDeepComponent user={user} onLogout={onLogout} />
    </Content>
  </Layout>
</App>

```

`Layout`, `Content`는 `user`, `onLogout` 안 쓰는데도,

그냥 아래로 넘겨주기 위해서 props를 들고 있어야 한다.

이로 인해 

1. **코드가 지저분해짐**
    - 중간 컴포넌트들이 *실제 관심사와 관계없는 props*를 계속 받아야 해서 컴포넌트 인터페이스가 복잡해짐.
2. **유지보수 지옥**
    - 아래 컴포넌트에 새로운 값이 필요하면, 상위 → 중간들 → 최하위까지 **전부 props 수정**해야 함.
3. **리팩터링이 힘듦**
    - 구조를 바꾸려 하면, 연결된 props 때문에 의존성이 많아서 손대기 부담스러움.
4. **불필요한 리렌더링**
    - 상위에서 props가 바뀌면, 실제로 안 써도 중간 컴포넌트들이 다 리렌더링될 가능성이 큼.

---

## <mark> 해결책 1 – React Context API </mark>

### 1. 개념 간단 정리

Context는 “전역처럼 공유되는 값”을 만들고,

필요한 컴포넌트에서 바로 꺼내 쓰게 해주는 메커니즘.

```tsx
// 1. Context 생성
const UserContext = createContext<User | null>(null);

// 2. 상위에서 공급(Provider)
function App() {
  const [user, setUser] = useState<User | null>({...});

  return (
    <UserContext.Provider value={user}>
      <Layout />
    </UserContext.Provider>
  );
}

// 3. 깊은 자식에서 바로 사용
function VeryDeepComponent() {
  const user = useContext(UserContext);
  return <div>{user?.name}님 안녕하세요</div>;
}

```

중간에 `props`로 계속 전달할 필요 없이, `Provider` 아래라면 어디서든 `useContext`로 접근 가능.

---

### 2. Context API의 장점

1. **프롭스 드릴링 제거**
    - 중간 컴포넌트들이 필요 없는 `props`를 계속 받지 않아도 됨.
2. **리액트 내장 기능**이라 별도 설치 X
    - `react`만 있으면 됨. 추가 의존성 없음.
3. **간단한 전역 상태에 최적**
    - ex) 로그인 유저 정보, 테마(`light/dark`), 언어 설정, 환경 설정 등.
4. **타입스크립트와 궁합 좋음**
    - 제네릭으로 타입 지정하면, IDE 자동완성 잘 됨.
5. 컴포넌트 트리 입장에서 의미 있는 “컨텍스트 경계”를 만들 수 있음
    - 예: `AuthProvider`, `ThemeProvider`, `SettingsProvider` 등으로 논리적 영역 구분.

---

### 3. Context API의 단점 / 주의점

1. **값이 바뀌면 Provider 아래가 전부 리렌더링될 수 있음**
    - `value`가 자주 바뀌는 상태(입력값, 실시간 숫자 등)를 Context에 넣으면
        
        해당 Provider 아래 컴포넌트들이 전부 영향을 받을 수 있음 → 성능 이슈.
        
    - 이를 줄이려면 상태를 쪼개거나, `memo`, custom hook, selector 패턴 등을 써야 해서 코드가 복잡해질 수 있다.
2. **복잡한 상태 로직에 잘 안 맞음**
    - 비동기 요청, 캐싱, undo/redo, 미들웨어 패턴 등은 Context로 직접 구현하기 번거로움.
    - 결국 “전역 변수 컨테이너”로 쓰다가 점점 스파게티될 수 있음.
3. **남용하면 또 다른 지옥**
    - 아무거나 다 Context에 넣기 시작하면,
        
        “전역 상태가 너무 커진 Redux”와 비슷한 문제가 생김.
        
    - 어디서 어떤 Context를 쓰는지 추적하기 어려워질 수 있음.
4. **디버깅 / DevTools의 한계**
    - 외부 라이브러리처럼 강력한 DevTools(타임 트래블 디버깅, 액션 로그 등)는 없음.
    - 상태 변화 흐름을 추적하기 어려울 수 있어요.

---

### 4. Context를 쓰기 좋은 상황

- 앱 전역에서 거의 모든 화면이 참고하는 값:
    - 로그인 유저 정보 (`currentUser`)
    - 토큰, 인증 상태 (`isAuthenticated`)
    - 테마, 언어, 레이아웃 설정
- 자주 바뀌지 않는 값 or 바뀌어도 리렌더 영향이 크지 않은 값
- 작은/중소규모 프로젝트에서 **간단하게 props drilling만 줄이고 싶을 때**

---

## <mark> 해결책 2 – 외부 상태 관리 라이브러리 </mark>

여기서 말하는 건 대략 이런 것들:

- **Redux / Redux Toolkit**
- **Zustand**
- **Recoil**
- **Jotai**
- **MobX** 등등

각 라이브러리마다 철학은 조금씩 다르지만, 보통 공통적으로

- **컴포넌트 밖에 “스토어”를 만들고**
- 컴포넌트가 **필요한 조각만 구독**해서 가져와 쓰는 방식.

예시 (Zustand 느낌):

```tsx
// store.ts
const useUserStore = create((set) => ({
  user: null,
  setUser: (user) => set({ user }),
}));

// 컴포넌트에서 사용
function VeryDeepComponent() {
  const user = useUserStore((state) => state.user);
  return <div>{user?.name}님 안녕하세요</div>;
}

```

`props`로 내려주지 않고, **어디서나 같은 store를 import & hook으로 접근**하는 느낌.

---

### 1. 외부 라이브러리의 장점

1. **상태와 UI의 강한 분리**
    - “상태/비즈니스 로직”을 store 파일에 모아서 관리 → 컴포넌트는 진짜 UI에만 집중 가능.
2. **프롭스 드릴링 완전 해결**
    - Context보다 더 구조적으로 깔끔하게 관리 가능(특히 큰 프로젝트).
3. **정교한 성능 최적화**
    - 선택자(selector)를 통해 **필요한 조각만 구독**해서 리렌더를 최소화할 수 있음.
    - 어떤 라이브러리는 기본적으로 “구독 단위”가 잘 설계되어 있음(Zustand, Recoil 등).
4. **강력한 DevTools & 디버깅** (예: Redux)
    - 액션 로그, 상태 타임라인, 타임 트래블 디버깅 등:
        - “언제, 어떤 액션 때문에 상태가 이렇게 바뀌었는지” 추적 가능.
5. **비동기 로직 / 미들웨어 지원**
    - Redux Thunk, Saga, RTK Query, Zustand의 미들웨어 등…
    - API 호출, 캐싱, 에러 처리, 리트라이 같은 비즈니스 로직을 깔끔하게 분리 가능.
6. **대규모 팀 협업에 유리**
    - 상태 구조, 액션 타입, 업데이트 패턴이 명확하면
        
        새로운 사람이 와도 흐름을 따라가기 쉬워짐.
        
7. **테스트 코드 작성이 수월**
    - store와 reducer(또는 updater)를 분리해서 단위 테스트하기 좋음.

---

### 2. 외부 라이브러리의 단점

1. **추가 러닝 커브**
    - Redux, MobX 같은 건 개념이 많아서 처음 도입할 때 공부 필요.
    - 심지어 “어떤 상태 라이브러리를 쓸지” 결정하는 것도 고민거리.
2. **보일러플레이트 가능성**
    - 특히 옛날 Redux 스타일은 코드량이 많았음.
    - 요즘은 Redux Toolkit 덕분에 많이 줄었지만, 그래도 “store, slice, action” 등 구조를 잡아야 함.
3. **의존성 증가 + 번들 사이즈 증가**
    - 작은 프로젝트에서는 굳이 외부 라이브러리가 과한 느낌일 수 있음.
4. **과도한 추상화 위험**
    - 너무 “모든 상태를 store에 넣자”고 하면
        
        로컬로 둬도 되는 상태까지 전역화돼서 오히려 복잡해짐.
        
5. **팀 합의 필요**
    - 어떤 라이브러리, 어떤 패턴, 어떤 파일 구조를 쓸지 팀 컨벤션이 필요.

---

##
