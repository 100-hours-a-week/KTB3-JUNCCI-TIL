# 📚 Spring Boot 핵심 개념 정리(JWT)

---
## <mark>JWT</mark>

> JWT(Json Web Token)는 JSON 형태의 정보를 안전하게 담아서 주고받기 위한 토큰 포맷이고,
> 
> 
> 주로 **인증/인가를 위한 토큰**으로 쓰인다.
> 
- "이 사람은 누구고"
- "어떤 권한이 있고"
- "언제까지 유효한지"

같은 정보를 **토큰 문자열 안에** 담아서 보내는 표준 규격입니다.

놀이공원 팔찌 비유로 보면:

- 입구에서 돈 내고 → 팔찌를 받음 (로그인, 토큰 발급)
- 놀이기구 탈 때마다 → 팔찌만 보여줌 (JWT 전송)
- 직원은 팔찌만 보고 “요금 냈구나” 판단 (서명 검증 → 인증 통과)

---

## JWT 구조 (Header / Payload / Signature)

JWT는 `aaa.bbb.ccc` 처럼 **`.`으로 3부분**으로 나뉩니다.

1. **Header**
    - 예: `{ "alg": "HS256", "typ": "JWT" }`
    - 어떤 알고리즘(HS256, RS256…)으로 서명됐는지, 타입이 JWT인지 등 **메타데이터**
2. **Payload**
    - 실제 데이터(Claim)가 들어가는 부분
    - 예:
        
        ```json
        {
          "sub": "userId-1",
          "role": "ADMIN",
          "exp": 1700000000
        }
        
        ```
        
    - 대표적인 Claim들:
        - `sub`: 주체(누구인가? – 유저 ID)
        - `exp`: 만료 시간
        - 그 외 커스텀: 권한, 닉네임 등
3. **Signature**
    - `Signature = HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret )`
    - Header + Payload를 비밀키(Secret Key)로 서명한 값
    - 이 부분 덕분에 **위변조 방지**가 된다.
        - 누가 Payload를 수정하면 서명이 더 이상 맞지 않아서 `유효하지 않은 토큰`이 됨

💡 **중요 포인트 – Self-contained**

- 세션 ID는 그 자체로는 아무 의미 없는 난수(`JSESSIONID=12345`)
    - “이게 누구 세션인지”는 서버가 따로 저장하고 있음
- JWT는 **토큰 자체에 정보가 들어있다.**
    - 디코딩하면 “이 사람이 누구고, 무슨 권한이고, 언제 만료되는지” 알 수 있음
    - 그래서 **서버가 상태를 기억할 필요가 없다 (Stateless)**

---

## Token 기반 인증 & Stateless

### 세션 기반 vs 토큰 기반

- **세션 기반**
    - 로그인 시: 서버 메모리/DB에 `(세션ID → 사용자 정보)` 저장
    - 클라이언트: 세션ID만 쿠키로 들고 다님
    - 서버는 세션 저장소를 **반드시** 들고 있어야 함 → **Stateful**
- **토큰 기반(JWT)**
    - 로그인 시: JWT를 발급해서 클라이언트에 전달
    - 클라이언트: 이 토큰을 보관했다가 매 요청마다 `Authorization: Bearer <token>` 로 보냄
    - 서버: 토큰 서명만 검증하면, 그 안에 유저 정보/권한이 다 들어있음 → 별도 세션 저장 X → **Stateless**

### Stateless in Spring Security

`SessionCreationPolicy.STATELESS`를 설정하면:

- Spring Security는 **세션을 만들지도, 사용하지도 않는다.**
- 요청 들어올 때마다 `SecurityContext`를 새로 만들고,
- 토큰 검증해서 `Authentication` 을 넣은 뒤,
- 요청 끝나면 그 컨텍스트를 버린다.

즉, “**서버가 과거를 기억하지 않는 구조**”가 되는 것.

---

## 왜 JWT를 쓰는가? (장점)

### 1) 확장성 (면접 1순위 키워드)

- 서버 여러 대로 확장(수평 확장)할 때 세션 방식의 문제:
    - A 유저가 서버1에 로그인해서 세션 생성
    - 다음 요청이 로드밸런서 때문에 서버2로 가면? → 서버2에는 세션이 없음 → 다시 로그인 or 세션 동기화 필요
- 해결책들:
    - **Sticky session**: 특정 유저는 항상 같은 서버로 → 한 서버에 트래픽 몰림
    - **Session clustering / Redis 세션 공유**: 세션 저장소를 공유 → 인프라 복잡도 ↑, 장애 포인트 추가
- JWT:
    - 서버는 **세션을 아예 안 들고** 토큰만 검증
    - 서버가 1대든 100대든 그냥 **모든 서버가 토큰만 검증하면 끝**
    - MSA 환경에서도 각 마이크로서비스가 JWT만 받아서 검증하면 된다.

### 2) 다양한 클라이언트 환경

- 옛날: 거의 다 브라우저 + 서버 → 쿠키/세션이 편함
- 지금: 모바일 앱(Android/iOS), SPA(React, Vue), 데스크톱 클라이언트 등 다양
    - 모바일 앱에서 쿠키/세션 처리 복잡
    - 토큰은 그냥 **헤더에 문자열 하나 넣어 보내면 끝**
        - `Authorization: Bearer <token>`

### 3) CORS 이슈 완화

- 쿠키는 도메인 기반, 자동 전송이라 CORS와 얽히면 설정이 꽤 복잡함
- 토큰은 그냥 문자열 → 도메인 달라도 헤더에 직접 넣어 보내면 되니까 상대적으로 단순

---

## JWT가 세션보다 무조건 좋은가? (단점)

**절대 만능 아님 (No Silver Bullet)**

### 1) 강제 만료/로그아웃이 어렵다

- 세션: 서버가 세션 삭제하면 끝 (`session.invalidate()`)
- JWT: 이미 발급된 토큰은 **유효기간 전까지는 원칙적으로 다 유효**
    - 누군가 토큰을 탈취했다면, 그 토큰이 만료될 때까지 막기 어렵다.
    - 보완책:
        - **Access Token + Refresh Token** 구조
        - *Blacklist(토큰 블랙리스트)**를 별도 저장소(Redis 등)에 두고 차단

### 2) 토큰 크기 & 정보 노출

- JWT는 Payload에 정보가 꽤 들어갈 수 있으니 **길어질 수 있음**
- 그리고 Base64 인코딩일 뿐이라, **누구나 디코딩해서 내용을 볼 수 있다.**
    - 민감정보(비밀번호, 주민번호 등)를 넣으면 안 된다.
    - 보호해야 할 건 **서명과 무결성**, 기밀성은 별도의 암호화로 처리해야 함.

---

## Spring Security에서 JWT가 도는 흐름

요청 기준으로 보면 대략 이렇게 흘러갑니다:

1. 클라이언트가 로그인 성공 → 서버가 JWT 발급
2. 클라이언트는 이 토큰을 저장해두었다가,
3. 이후 요청마다 헤더에 `Authorization: Bearer <token>` 넣어서 보냄
4. `JwtFilter`(커스텀 필터)가 매 요청마다 실행:
    - 헤더에서 토큰 꺼내기
    - 유효성 검증 (만료 여부, 서명 검증)
    - 유효하면 `Authentication` 객체 생성 (`UsernamePasswordAuthenticationToken` 등)
    - `SecurityContextHolder.getContext().setAuthentication(authentication)`
5. 이후 Spring Security는 일반 세션 로그인과 동일하게 동작:
    - `@PreAuthorize("hasRole('ADMIN')")` 이런 것들 전부 동작
6. 요청이 끝나면 `SecurityContext`는 버림 (Stateless)

예외는 필터 단계에서 던져지므로, `@ControllerAdvice` 대신

- `AuthenticationEntryPoint` → 인증 실패(401)
- `AccessDeniedHandler` → 인가 실패(403)

로 처리한다는 것도 기억.

---

## JWT를 어디에 저장할까? (XSS / CSRF)

### 1) localStorage에 저장 (간단하지만 위험)

- 장점: 구현이 매우 쉽다.
- 단점: **XSS 공격에 취약**
    - 공격자가 악성 스크립트를 주입해서 `localStorage.getItem('token')` 실행 → 토큰 탈취

그래서 “그냥 로컬스토리지에 넣자”는 건 실무에선 욕 먹기 좋다.

### 2) HttpOnly Cookie에 저장

- **HttpOnly 옵션** 쿠키
    - 브라우저는 서버로 쿠키를 자동 전송하되,
    - 자바스크립트에서는 절대로 접근 불가 (`document.cookie`에서도 안 보임)
    - XSS로 스크립트가 실행되어도 쿠키를 훔칠 수 없다 → 토큰 탈취 난이도↑
- 대신 **CSRF**를 다시 신경 써야 함
    - 쿠키는 자동 전송되므로, 악성 사이트에서 사용자를 대신해 요청을 보내는 공격 가능
    - 해결책:
        - CSRF 보호 켜기
        - `SameSite=Strict`/`Lax` 설정, CSRF 토큰 사용 등

### 3) Access Token + Refresh Token 조합 (실무에서 가장 흔함)

- **Access Token**
    - 수명 짧게 (예: 15분~30분)
    - 응답으로 내려주고, 프론트는 **메모리(변수)**에만 저장
    - 새로고침하면 사라져서 XSS에 어느 정도 방어
- **Refresh Token**
    - 수명 길게 (예: 7일~14일)
    - HttpOnly 쿠키에 저장하고, `path=/reissue` 등 재발급 API에만 전송
    - 재발급 요청 시 서버는 DB/Redis에서 Refresh Token 상태를 한 번 확인
        - 탈취/로그아웃/강제 차단 여부 확인 가능

이 구조로

- 사용성(자동 로그인 유지)과
- 보안(탈취 피해 최소화)

사이에서 균형을 맞춥니다.

---

## JWT 관련 함정들

간단히 체크리스트처럼 보자면:

1. **CSRF 무지성 disable**
    - 토큰을 **쿠키에** 담는다면 CSRF 보호를 꺼버리면 안 된다.
2. **CORS를 MVC에서만 설정**
    - Security 필터에서 막힌 요청에 CORS 헤더가 안 붙어, 프론트가 “CORS 오류”로 오해
    - → Security 레벨에서 `CorsFilter` 또는 `http.cors()` 설정 필요
3. **hasRole vs hasAuthority**
    - `hasRole("ADMIN")` → 내부적으로 `ROLE_ADMIN` 찾는다.
    - DB에 `ADMIN` 만 저장했다면 → `hasAuthority("ADMIN")` 사용.
4. **Secret Key/DB 비밀번호를 yml에 평문 저장**
    - 절대 깃허브에 올라가면 안 됨 → 환경 변수, 시크릿 매니저 사용

---

##
