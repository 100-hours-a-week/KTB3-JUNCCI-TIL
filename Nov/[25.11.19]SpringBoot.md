# 📚 Spring Boot 핵심 개념 정리(CSRF, JWT)

---
# <mark> CSRF(Cross-Site Request Forgery) </mark>

---


핵심 문장 하나로 설명하면

> CSRF = 서버는 “누구인지”는 알지만 “정말 그 사람이 이 요청을 보낸 건지(의도)”는 모르는 문제
> 

### 왜 이런 문제가 생길까?

- 브라우저는 너무 친절해서:
    
    > “목적지가 같은 사이트라면 그냥 쿠키를 자동으로 붙여보내자!”
    > 
- 하지만 브라우저는 의도(intent)는 판단하지 않는다.
    
    단지 **쿠키가 있으니 인증된 사용자라고 착각**하는 것.
    

### 세션 쿠키는 인증 증표일 뿐, 의도 증표가 아니다

그래서 추가 증표(CSRF Token)가 필요하다.

---

## 브라우저 구조와 웹 보안 주요 특징 추가 설명

### SameSite 쿠키와 CSRF의 과거/현재

최근 브라우저들은 CSRF 때문에 SameSite 정책을 강화했다.

### SameSite 옵션 세 가지

| 옵션 | 설명 | CSRF 방어 효과 |
| --- | --- | --- |
| **Strict** | 완전한 same-site 요청에서만 쿠키 전송 | CSRF 거의 완전 차단 |
| **Lax(기본값)** | 일부 cross-site GET에서는 허용, POST는 불가 | 기본적인 CSRF 차단 |
| **None** | cross-site 요청에도 항상 쿠키 전송 | CSRF 취약 → 반드시 Secure 필요 |

→ **Chrome이 SameSite=Lax를 기본값으로 바꾼 이후 CSRF 공격 난이도는 매우 올라감**

→ 하지만 여전히 **POST 기반 CSRF**, 프레임 기반 CSRF(Clickjacking)는 여전히 가능

### 그래서 실무에서는

**“SameSite=Lax면 CSRF 안 해도 되나요?” → NO.**

- 기업 서비스/은행/관리자 페이지는 여전히 CSRF Token 필수
- 정책이 바뀔 수 있고, 일부 브라우저는 완전히 일관적이지 않음

---

## 현대 웹 개발에서 CSRF가 성립하는 경우 / 안 되는 경우 요약

### CSRF 공격이 **성립하는 경우**

### 쿠키 기반 인증(Session, JWT-in-cookie)

- 브라우저가 쿠키 자동 첨부
- 공격 사이트에서도 자동으로 쿠키 붙음
- → **필연적으로 CSRF 위험 존재**

### 쿠키에 httponly, secure 등을 적용해도 CSRF는 살아있다

- httponly: JS가 못 읽을 뿐
- secure: HTTPS에서만 전송
    
    → **자동 전송이라는 쿠키의 성질은 절대 바뀌지 않는다**
    

---

### CSRF 공격이 **성립하지 않는 경우**

### JWT를 localStorage/sessionStorage에 저장한 경우

- JS가 직접 읽어서 Authorization 헤더 넣어주는 방식
- 브라우저가 자동으로 헤더를 만들어주지 않음
- 다른 사이트에서 localStorage 접근 불가 (SOP)
    
    → **공격자가 헤더를 만들 수 없으므로 CSRF 불가능**
    

### Token 기반 인증인데 쿠키 사용 안 하는 경우

- 예: OAuth Bearer Token을 명시적으로 헤더로 넣는 API 호출
    
    → CSRF 공격 불가능
    

---

## 안전하다고 착각하기 쉬운 실수들

### “우리 사이트는 Post로만 중요한 작업해요” → CSRF 막지 못함

form 자동 submit으로 POST도 쉽게 날림.

### “CORS 설정 잘 했어요” → CORS는 CSRF 차단하지 않음

- CORS는 “응답을 읽을 수 있는지 여부”를 제어
- CSRF는 “요청을 보내는 것 자체”가 공격임
    
    → 둘은 전혀 다른 목적
    

### 동일 출처 정책(SOP)이 CSRF를 막아주는 게 아니다

- SOP는 **응답 읽기**를 막음
- 하지만 **요청 보내기 자체는 막지 않음**
    
    → CSRF는 “읽기(read)”가 아니라 “쓰기(write)” 공격
    

이 부분은 면접 단골 질문임:

> Q. CORS가 CSRF를 방어하지 못하는 이유를 설명해보세요.
> 

---

## CSRF Token 방어를 우회하기 위한 공격자가 시도하는 것들

### CSRF Token을 공격자가 훔치면?

- 이 경우 방어 무력화됨
- 그래서 **CSRF Token + SameSite Cookie** 조합이 권장됨
- 서버는 토큰을 비밀스럽게(HTML 내부, JS 변수 등) 전송하고 SOP가 이를 지켜줌

### Single Token vs Double Submit Cookie 패턴

### Single Token

- 서버 세션에 저장하고 비교
    
    → 주로 서버에 세션 있는 환경(SSR)
    

### Double Submit Cookie

- 토큰을 쿠키에도 넣고, JS가 읽어서 헤더로 보냄
    
    → 서버는 쿠키 값 vs 헤더 값을 비교
    
    → 서버가 세션 없어도 가능(stateless)
    

이렇게 **세션 없는 CSRF Token 방식**도 있다는 것을 기억해야 함. (중요!)

---

## SPA(React/Vue) + Spring Security 환경에서 어떻게 CSRF 처리하는가

### JWT를 **localStorage**에 두는 경우

- Authorization 헤더 자동 생성해 요청 → CSRF 필요 없음
- XSS에 취약해짐
- SPA에서 흔히 취하는 방식

### JWT를 **httpOnly Cookie**에 넣는 경우

- XSS 안전
- 하지만 쿠키 기반 인증이므로 **CSRF 다시 생김**
    
    → SameSite=Lax + CSRF Token 조합 필요
    
    → 많은 서비스가 이 패턴
    

이 부분은 실제 팀/백엔드/프론트 협업에서 공급자가 가장 많이 실수함.

---

## CSRF와 Clickjacking 관계

Clickjacking을 이용해 의도치 않은 행동을 수행하게 하여 **CSRF를 더 쉽게 유도**할 수 있음.

그래서 많은 서비스는 CSRF와 함께:

```
X-Frame-Options: DENY

```

또는

`Content-Security-Policy: frame-ancestors 'none'`

을 설정함.

---

# <mark>  JWT </mark> 

**JWT(JSON Web Token)** =

> “JSON 데이터를 안전하게 서명해서, 토큰 하나로 인증/권한 정보를 주고받는 표준 포맷”
> 
- 주로 **인증/인가 토큰**으로 사용
- 서버가 토큰 안에 필요한 정보를 넣고 **서명(signature)** 해서 클라이언트에게 발급
- 클라이언트는 이후 요청마다 이 토큰을 보내고, 서버는 토큰을 검증해서
    - “누구인지(유저)”
    - “권한이 있는지(roles/scopes)”
        
        를 판단
        

**핵심 특징**

- 문자열 하나로 구성된 **자급자족(self-contained)** 토큰
- 서버가 세션 저장소를 들고 있지 않아도 토큰 자체만으로 인증 가능 → **stateless 인증** 가능

---

## JWT 구조: 점(.) 2개로 나뉘는 3부분

형태는 항상 이렇죠:

```
xxxxx.yyyyy.zzzzz
(header).(payload).(signature)

```

각 부분은 **Base64URL 인코딩된 JSON**입니다.

---

### Header

어떤 알고리즘으로 서명했는지 등의 메타 정보.

```json
{
  "alg": "HS256",    // 서명 알고리즘 (예: HS256, RS256...)
  "typ": "JWT"       // 타입 (거의 항상 "JWT")
}

```

이걸 Base64URL로 인코딩하면 첫 번째 조각 `xxxxx` 가 됩니다.

---

### Payload (Claims)

실제 우리가 쓰고 싶은 **유저 정보 + 메타 데이터**가 들어가는 부분.

여기 들어가는 단위들을 Claim(클레임)이라고 부름.

예:

```json
{
  "sub": "1234567890",      // subject: 유저 식별자 (대상)
  "name": "Alice",
  "role": "ROLE_USER",
  "iat": 1710000000,        // issued at (발급 시간, Unix timestamp)
  "exp": 1710003600         // expiration (만료 시간)
}

```

이 JSON도 Base64URL 인코딩 → 두 번째 조각 `yyyyy`

---

### Signature

앞의 두 조각을 이어 붙여 서명한 값:

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secretKey
)

```

- 이 결과를 Base64URL 인코딩 → 세 번째 조각 `zzzzz`
- 서버는 이 서명을 이용해:
    - “이 토큰이 **우리 서버가 만든 토큰인지**”
    - “중간에 **내용이 변조되지 않았는지**”
        
        를 확인
        

---

## 서명 알고리즘: HS256 vs RS256

JWT에서 많이 쓰는 알고리즘 두 가지:

### HS256 (HMAC + SHA-256)

- **대칭키 방식**
- 서명/검증에 같은 secret key 사용
- 장점: 단순, 빠름
- 단점:
    - 토큰을 검증해야 하는 서버들이 **모두 secret을 공유**해야 함
    - secret 유출 시 전체 시스템 위험

### RS256 (RSA + SHA-256)

- **비대칭키 방식 (공개키/비밀키)**
- 서명: private key
- 검증: public key
- 장점:
    - 토큰 발급 서버만 private key를 가지고 있고, 다른 서비스들은 public key만 있으면 검증 가능 → **마이크로서비스 구조**에 잘 맞음
- 단점:
    - 구현/키 관리가 조금 더 복잡, 속도도 HS256보다 느릴 수 있음

---

## JWT가 실제로 어떻게 쓰이는지 흐름

**1) 로그인 요청**

- 클라이언트: `/login` 같은 엔드포인트에 아이디/비번 전송

**2) 서버에서 인증 성공**

- DB에서 유저 확인, 비밀번호 매칭 등 인증 완료

**3) 서버가 JWT 발급**

- payload에 유저 정보/권한/만료시간 등 넣고 서명하여 JWT 생성
- 이 JWT를 클라이언트에게 반환
    - API 응답 JSON에 넣거나
    - 쿠키에 심거나 등

**4) 클라이언트가 JWT 저장**

- 예:
    - `localStorage` 또는 `sessionStorage`
    - httpOnly 쿠키
    - 메모리(리덕스/상태 관리 등)

**5) 이후 API 호출**

- 클라이언트가 Authorization 헤더로 토큰 첨부:

```
Authorization: Bearer <jwt_token_here>

```

**6) 서버에서 매 요청마다 토큰 검증**

- 토큰 서명 검증 (secret 또는 public key로)
- `exp`(만료 시간) 확인
- 필요하면 `sub`, `role`, `scope` 등을 꺼내 권한 체크
- 유효하면 “인증된 요청”으로 처리

---

# Payload 안에 들어가는 Claim들

### RFC에서 정의한 “Registered Claims”

일부는 권장, 일부는 선택.

- `iss` (issuer): 토큰 발급자
- `sub` (subject): 토큰 대상 (보통 유저 ID)
- `aud` (audience): 토큰이 사용될 대상(앱, 서비스)
- `exp` (expiration): 만료 시간 (이 시간 이후는 무효)
- `nbf` (not before): 이 시간 전에는 유효하지 않음
- `iat` (issued at): 발급 시간
- `jti` (JWT ID): 토큰 식별자(중복 발급 구분, 블랙리스트/화이트리스트에 사용)

### Custom Claims (애플리케이션 용도에 맞게 자유롭게)

예:

- `role` / `roles` : USER, ADMIN 등
- `scope`: `read:user`, `write:post` 같은 권한 범위
- `email`, `nickname`, `organization` 등

**주의**: 민감한 정보(주민번호, 비밀번호, 카드번호 등) 절대 넣지 말 것.

→ JWT는 **서명만 되어있지 암호화된 게 아니라서, 누구나 디코딩해서 내용 볼 수 있음.**

---

# JWT vs 서버 세션 (JSESSIONID 등) 비교

## 세션 방식

- 서버가 `session store`(메모리, Redis 등)를 가지고 있음
- 로그인 성공 시 `sessionId` 생성, 서버 메모리에 유저 정보 저장
- 클라이언트에 `sessionId`를 쿠키로 전송
- 이후 요청마다 쿠키로 `sessionId`가 와서 서버에서 세션 조회

**장점**

- 세션 위험(탈취 등) 시 서버에서 해당 세션만 바로 만료 가능
- 토큰 내용이 서버에 있기 때문에 응답에서 노출할 일이 적음

**단점**

- 서버에 **상태(state)**를 유지해야 함
- 서버 수평 확장 시 세션 공유를 위한 Redis 같은 추가 인프라 필요

---

## JWT 방식

- 서버가 토큰 안에 정보를 넣고 **서명만 한 뒤**, 별도의 저장 없이 클라이언트에게 줌
- 요청마다 오는 JWT 자체만 검증하면 됨 (서버에서 토큰 상태를 안 들고 있어도 됨)

**장점**

- 서버가 Stateless → 수평 확장 쉬움
- 별도 세션 저장소 필요 없음
- 여러 서비스 간 인증 공유가 편함(특히 RS256 + public key 구조)

**단점**

- **발급 후 마음대로 토큰 하나만 “무효화”하기가 까다로움**
    - 일반적으로는 `exp`가 끝날 때까지 유효
    - 그래서 실무에서는 단기 access token + long refresh token 구조를 씀
- 토큰 길이가 길 경우 헤더 부담
- 잘못 설계하면 민감한 정보가 그대로 노출될 위험 (payload는 인코딩일 뿐 암호화 아님)

---

## JWT 저장 위치와 보안 이슈 (CSRF, XSS 연관)

당신이 전에 CSRF 정리한 것과 딱 맞물리는 부분.

### localStorage에 저장

**장점**

- JS로 접근하기 쉽고 구현이 편함
- 쿠키 설정, SameSite, Domain 고민 상대적으로 덜 함

**단점 / 위험**

- XSS 취약점이 있으면 공격자가 `localStorage.getItem("token")`으로 바로 탈취 가능
- CSRF는 성립하지 않지만(헤더 자동 전송 안 하니까), 대신 **XSS에 아주 민감**

→ 보통 SPA에서 간편하게 많이 쓰지만, XSS 방어에 신경 많이 써야 함.

---

### httpOnly 쿠키에 저장

**장점**

- JS에서 쿠키를 읽을 수 없으므로 XSS로 토큰 직접 탈취하기 어려움
- 브라우저가 자동으로 첨부 → 코드 단순

**단점**

- 쿠키 기반 → **CSRF 다시 성립**
- SameSite, CSRF Token, CORS 정책 등 종합적으로 설계해야 함

→ XSS에는 강하지만 CSRF에 취약 → 그래서 보통:

> JWT + httpOnly 쿠키 + SameSite=Lax/Strict + CSRF Token
> 

조합으로 방어.

---

### 메모리(전역 변수, 상태 관리 라이브러리)에 저장

- 페이지 새로고침하면 날아감 → UX 상 불편
- 하지만 XSS로 탈취는 여전히 가능 (JS 접근 가능)
- 실제로는 access token을 메모리에만 두고, refresh token은 httpOnly cookie에 두는 하이브리드 패턴도 있음

---

## Access Token & Refresh Token 패턴

실무에서 JWT를 쓰면 거의 항상 나오는 구조.

### Access Token

- 수명이 짧음 (예: 5분, 10분, 30분)
- 모든 API 호출에 사용
- 탈취되더라도 피해 기간을 최소화하기 위함

### Refresh Token

- 수명이 길음 (일주일, 한 달 등)
- Access Token이 만료되었을 때 다시 발급받는 용도
- 위험도가 크기 때문에 일반적으로:
    - 서버 DB에 저장하고 관리하거나
    - httpOnly + Secure 쿠키로 보관
    - 또는 Redis 등에 넣고 블랙리스트/화이트리스트 관리

**흔한 흐름**

1. 로그인 성공 → access + refresh 둘 다 발급
2. access 만료 → 클라이언트가 refresh를 이용해 새 access 요청
3. 로그아웃 or 보안 사고 → 서버에서 해당 refresh를 DB에서 제거 or 블랙리스트 처리
    
    → 이후 토큰 재발급 불가
    

---

## JWT 사용할 때 꼭 조심할 것들

1. **민감한 정보 넣지 말기**
    - payload는 base64URL 인코딩일 뿐, 누구나 디코딩해서 볼 수 있음.
2. **`exp` 꼭 설정하기**
    - 만료 없는 토큰 = 사고 나면 끝장
3. **서명 알고리즘 하드코딩 / 명시**
    - `alg: none` 취약점 같은 잘못된 구현 피하기
    - 서버에서 허용하는 알고리즘을 직접 지정하고, 인가되지 않은 알고리즘은 거부
4. **키 관리 철저**
    - secret key / private key 유출 = 토큰 마음대로 발급 가능
5. **토큰 크기 관리**
    - 너무 많은 데이터 넣으면 헤더 커지고 성능 저하
6. **로그에 토큰 통째로 찍지 말기**
    - 디버깅한다고 전체 토큰 찍어두면 로그가 정보 유출 포인트가 됨

---

## 헷갈렸던 개념들 정리

**Q1. JWT와 세션의 차이점은?**

- 세션은 서버에 상태 유지, JWT는 토큰 자체에 상태 포함(Stateless)
- 세션은 서버에 저장소 필요, JWT는 필요 없음
- 세션은 서버에서 자유롭게 만료 조정 가능, JWT는 보통 exp까지 유효(별도 blacklist 필요)

---

**Q2. JWT를 localStorage에 저장 vs httpOnly Cookie에 저장?**

- `localStorage`:
    - CSRF: X (헤더 자동 첨부 없음)
    - XSS: 매우 취약
- `httpOnly Cookie`:
    - XSS: 토큰 탈취 어려움
    - CSRF: 취약 → SameSite, CSRF 토큰 필요

---

**Q3. 왜 JWT에는 비밀번호 같은 민감한 데이터를 넣으면 안 되나요?**

- JWT payload는 누구나 디코딩 가능
- 서명은 “변조 방지용”이지 “내용 암호화”가 아님
    
    → 민감 정보는 절대 넣지 않고, 필요하다면 토큰 안에는 ID 정도만 넣고 서버에서 다시 조회
    

---
