# 📚 React 핵심 개념 정리(props, state)

---
# <mark> Props </mark>

**Props는 React 컴포넌트가 부모 컴포넌트로부터 전달받는 읽기 전용 데이터이다.**

- 컴포넌트 간 **데이터 전달을 위한 메커니즘**
- 부모 → 자식 **단방향 데이터 흐름**을 따름
- 전달받은 값을 컴포넌트 내부에서 **변경할 수 없음** (immutable)

Props = Properties(속성)의 줄임말

---

## Props를 사용하는 이유

React는 UI를 컴포넌트 단위로 구성한다.

이때 컴포넌트 간 재사용성·동적 UI·상황에 따라 UI를 조절하기 위해 데이터를 전달해야 한다.

Props의 주요 목적

### 컴포넌트 재사용성 증가

```jsx
<Button text="저장" />
<Button text="삭제" />

```

같은 컴포넌트가 다른 Props만으로 완전히 다른 UI처럼 동작 가능.

### 부모→자식 데이터 흐름 통합

React 철학인 단방향 데이터 흐름(One-way Data Flow)을 기반으로 설계.

### 상태 없는 컴포넌트에서 데이터 전달 가능

Props만으로 화면만 렌더링하는 프레젠테이셔널 컴포넌트 생성 가능.

---

## Props의 작동 원리

1. 부모 컴포넌트에서 자식 컴포넌트 호출
2. JSX 속성 형태로 값 전달
3. 자식 컴포넌트 함수의 **매개변수**로 전달됨
4. 자식 컴포넌트는 전달받은 값을 렌더링에 사용
5. Props는 절대로 컴포넌트 내부에서 수정할 수 없음

---

## Props 사용 예제

### 부모 컴포넌트

```jsx
function App() {
  return <Greeting name="Alice" age={20} />;
}

```

### 자식 컴포넌트

```jsx
function Greeting({ name, age }) {
  return <h1>{name}님은 {age}살입니다.</h1>;
}

```

---

## Props와 State의 차이

| 구분 | Props | State |
| --- | --- | --- |
| 데이터 제공 | 부모 컴포넌트 | 컴포넌트 내부 |
| 변경 가능? | 불가능 | 가능(setState) |
| 목적 | 컴포넌트 간 데이터 전달 | 동적인 값 관리 |
| 소유자 | 부모 | 자신(또는 useState 사용) |

Props는 "외부에서 온 데이터",

State는 "내부에서 관리하는 데이터".

---

## Props의 고급 패턴

### 1) Props Drilling

필요한 컴포넌트가 깊은 위치에 있어 데이터를 계속 아래로 전달해야 하는 문제.

### 2) Children Props

컴포넌트 태그 내부의 내용을 전달.

```jsx
<Card>
  <p>내용입니다</p>
</Card>

```

### 3) Render Props

함수를 Props로 전달해 UI를 동적으로 구성하는 패턴.

### 4) Default Props

전달되지 않을 경우 기본값 설정 가능.

---

## Props 사용 시 주의점

### Props 값 변경하지 말 것

```jsx
props.name = "Bob" // 오류!

```

### 너무 많은 props 전달 지양

하위 컴포넌트가 복잡해짐 → 리팩토링 필요

### props drilling 심할 경우

Context API, Zustand/Recoil 등 전역 상태 관리 사용 고려

---

## Context로 Props Drilling 해결하기

Context API를 사용하면 “전역처럼” 데이터를 관리하면서
중간 컴포넌트들을 거치지 않고 바로 필요한 컴포넌트에게 값을 전달할 수 있다.

React에서 Context는 다음을 제공함

- 글로벌 상태처럼 데이터 공유
- 중간 단계 컴포넌트를 거치지 않음
- props drilling 제거
- 간결한 구조 유지 가능

---

## Context 기본 구성 요소

Context는 아래 3가지로 구성된다.

1. **Context 생성**
    
    ```jsx
    const MyContext = createContext();
    ```
    
2. **Provider로 값 전달**
    
    주로 상위 컴포넌트에서 값 제공
    
    ```jsx
    <MyContext.Provider value={값}>
        ...하위 컴포넌트...
    </MyContext.Provider>
    ```
    
3. **useContext로 값 가져오기**
    
    ```jsx
    const value = useContext(MyContext);
    ```
    

---

# <mark> State </mark>

- State(상태)는 **컴포넌트 내부에서 관리되는 동적인 데이터**이다.

시간에 따라 값이 변하면서 컴포넌트의 UI를 업데이트할 수 있는 React의 핵심 개념.

> “React 컴포넌트가 스스로 기억하고 변화시키는 값”
> 

Props는 **외부(부모)에서 주는 값**,

State는 **컴포넌트 내부에서 스스로 관리하는 값**.

---

## State를 사용하는 이유

React는 UI를 **데이터 기반으로 업데이트**한다.

사용자 인터랙션 또는 내부 로직에 따라 UI가 계속 변해야 하는데,

이때 변하는 값(=상태)을 저장하고 업데이트해야 한다.

State는 다음을 위해 필요함.

- 사용자 입력 처리 (폼, 인풋 등)
- UI 열림/닫힘, 토글 등
- 서버 요청 데이터 관리
- 애니메이션, 페이지 상태 관리
- 컴포넌트가 기억해야 하는 값 저장

---

## State의 특징

| 특징 | 설명 |
| --- | --- |
| 변경 가능 | 값이 바뀌면 UI도 자동으로 렌더링됨 |
| 컴포넌트 내부 소유 | 부모/다른 컴포넌트는 직접 수정 불가능 |
| 비동기 업데이트 | setState는 즉시 반영되지 않음 |
| 렌더링 트리거 | state가 바뀌면 해당 컴포넌트가 재렌더링됨 |
| immutable(불변성) 원칙 | 기존 값을 직접 수정하면 안 됨 |

---

## State 작동 원리

1. `useState()` 훅으로 상태 변수(state variable) 생성
2. `setState()`로 상태 값을 변경
3. 값이 바뀌면 React는 컴포넌트를 다시 렌더링
4. 렌더링된 UI에 **변경된 state가 반영**됨
5. 필요한 경우 자식 컴포넌트로 props를 통해 전달 가능 **변수**

---

### useState 구조 이해하기

```jsx
const [state, setState] = useState(initialValue);

```

`state`

현재 상태 값 (읽기)

`setState()`

새로운 상태값을 할당하는 함수

값이 바뀌면 컴포넌트 재렌더링

`initialValue`

처음 상태의 값

---

## State에서 중요하게 알아야 할 개념들

### (1) 상태는 직접 변경하면 안 된다 → 불변성

잘못된 예:

```jsx
count++;

```

올바른 예:

```jsx
setCount(count + 1);

```

---

### (2) 상태 업데이트는 비동기적일 수 있음

즉시 반영되지 않을 수 있으므로 이전 값을 기준으로 업데이트해야 할 때는:

```jsx
setCount(prev => prev + 1);

```

---

### (3) 렌더링을 트리거 한다

State가 바뀌면 해당 컴포넌트와 자식 컴포넌트가 렌더링됨.

---

### (4) 여러 개의 상태를 가질 수 있음

```jsx
const [name, setName] = useState("");
const [age, setAge] = useState(0);
const [isOpen, setIsOpen] = useState(false);

```

---
