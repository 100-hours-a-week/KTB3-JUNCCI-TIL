# 📚 JavaScript 핵심 개념 정리(비동기 / 동기 / 논블로킹 / 블로킹)


---

## 자바스크립트의 실행 원리 정리
<img width="2103" height="2506" alt="Mermaid Chart - Create complex, visual diagrams with text -2025-11-05-053747" src="https://github.com/user-attachments/assets/c271949c-3f01-41cd-b265-34316d2c7688" />


### 1️⃣ 싱글 스레드 (Single Thread)

* 자바스크립트는 **한 번에 하나의 작업만 실행할 수 있는** 언어다.
* 코드 실행의 경로가 하나뿐이기 때문에 여러 일을 “동시에” 처리하지는 못한다.
* 하지만 **비동기 처리와 런타임 환경**을 활용해 동시에 실행되는 것처럼 보이게 만든다.

---

### 2️⃣ 콜 스택 (Call Stack)

* **현재 실행 중인 코드의 함수 호출 순서를 관리**하는 스택 구조.
* 함수가 호출되면 스택에 쌓이고(push), 실행이 끝나면 제거(pop)된다.
* 자바스크립트 엔진은 이 스택을 하나씩 처리한다.

---

### 3️⃣ Web API

* 브라우저나 Node.js가 제공하는 **비동기 작업 처리 영역**.
* `setTimeout`, `fetch`, `DOM Event` 등은 JS 엔진이 직접 처리하지 않고 Web API에 위임된다.
* Web API는 완료된 작업의 콜백을 **태스크 큐(Task Queue)** 로 보낸다.

---

### 4️⃣ 태스크 큐 (Task Queue)

* Web API에서 **완료된 콜백 함수들이 대기하는 공간**이다.
* 콜 스택이 비면, 이벤트 루프가 큐에서 대기 중인 콜백을 스택으로 옮겨 실행한다.

---

### 5️⃣ 이벤트 루프 (Event Loop)

* **콜 스택이 비었는지**, **큐에 대기 중인 함수가 있는지**를 계속 감시한다.
* 스택이 비면 큐에서 함수를 꺼내 실행시켜 비동기 처리를 가능하게 한다.
* 또한, **Microtask → Macrotask 순서**로 작업을 우선 처리한다.

---

### 6️⃣ 마이크로태스크(Microtask) vs 매크로태스크(Macrotask)

| 구분            | 예시                                   | 실행 시점              | 우선순위 |
| ------------- | ------------------------------------ | ------------------ | ---- |
| **Microtask** | `Promise.then`, `queueMicrotask`     | 매크로태스크 한 번 실행 후 즉시 | 높음   |
| **Macrotask** | `setTimeout`, `setInterval`, `fetch` | 다음 이벤트 루프 사이클마다    | 낮음   |

**실행 순서 예시:**

```js
console.log(1);
setTimeout(() => console.log(2), 0);
Promise.resolve().then(() => console.log(3));
console.log(4);
```

**결과:**

```
1
4
3
2
```

> Promise(마이크로태스크)가 setTimeout(매크로태스크)보다 먼저 실행된다.

---

## 블로킹 / 논블로킹 / 동기 / 비동기 정리

### 핵심 관점 구분

* **블로킹 vs 논블로킹 → 제어권(실행 흐름의 차이) 관점**
* **동기 vs 비동기 → 순서와 결과 처리(작업 완료 시점) 관점**

---

### 1️⃣ 블로킹 (Blocking)

* **작업이 끝날 때까지 제어권을 돌려주지 않는다.**
* 현재 실행 중인 함수가 끝나기 전까지 **다음 코드가 실행되지 않는다.**

```js
const data = readFileSync("file.txt"); // 파일 다 읽을 때까지 대기
console.log("파일 읽기 완료"); // 위 코드가 끝나야 실행
```

➡️ 결과: 제어권을 점유 → 다음 코드 실행 “멈춤”.

---

### 2️⃣ 논블로킹 (Non-Blocking)

* **작업을 요청하고 바로 제어권을 반환한다.**
* 작업이 끝나지 않아도 다음 코드가 실행된다.
* 완료 후 콜백이나 Promise로 결과를 처리한다.

```js
readFile("file.txt", () => {
  console.log("파일 읽기 완료");
});
console.log("다음 코드 실행");
```

➡️ 결과: 제어권 즉시 반환 → 다음 코드 먼저 실행.

---

### 3️⃣ 동기 (Synchronous)

* **작업이 순서대로 실행된다.**
* 앞의 작업이 끝나야 다음 작업이 시작된다.
* 실행 순서가 예측 가능하지만 느릴 수 있다.

```js
console.log("A");
console.log("B");
console.log("C");
```

➡️ 항상 A → B → C 순서로 실행.

---

### 4️⃣ 비동기 (Asynchronous)

* **작업이 완료되는 순서와 상관없이 결과를 처리한다.**
* 시간이 걸리는 작업을 백그라운드(Web API 등)로 위임하고, 나중에 콜백 또는 Promise로 결과를 받는다.

```js
console.log("A");
setTimeout(() => console.log("B"), 1000);
console.log("C");
```

➡️ 실행 순서: A → C → (1초 후) B

---

### 📋 비교 표로 요약

| 구분       | 기준    | 특징                     | 예시                               |
| -------- | ----- | ---------------------- | -------------------------------- |
| **블로킹**  | 제어권   | 작업 완료 전까지 다음 코드 실행 안 됨 | `readFileSync()`                 |
| **논블로킹** | 제어권   | 요청 후 제어권 즉시 반환         | `readFile()`                     |
| **동기**   | 실행 순서 | 순차적으로 실행               | `console.log` 순서 실행              |
| **비동기**  | 실행 순서 | 완료 시점에 콜백/Promise 실행   | `setTimeout`, `fetch`, `Promise` |

---

