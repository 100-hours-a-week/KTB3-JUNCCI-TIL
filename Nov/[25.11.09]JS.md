# 📚 JS 핵심 개념 정리(Hoisting)

---
## <mark> 호이스팅 (Hoisting) </mark>


---

## 정의

**호이스팅(hoisting)** 은

> 자바스크립트 엔진이 코드를 실행하기 전에,
> 
> 
> **변수와 함수 선언부를 해당 스코프의 최상단으로 끌어올린 것처럼 처리하는 메커니즘**입니다.
> 

실제 코드가 이동하는 것은 아니지만,

**“선언 단계가 실행되기 전에 처리되는 과정”** 때문에

마치 코드가 위로 올라간 것처럼 보입니다.

---

## 동작 원리 — 실행 컨텍스트와의 관계

자바스크립트 엔진은 코드를 실행할 때 **두 단계**를 거칩니다.

### (1) 생성 단계 (Creation Phase)

- 실행 컨텍스트가 만들어짐
- 변수, 함수 선언을 스캔함
- **메모리 공간 확보 (Environment Record 생성)**
- `var` 변수는 `undefined` 로 초기화
- `let`, `const` 변수는 **TDZ(Temporal Dead Zone)** 에 들어감
- 함수 선언문은 **전체 함수 객체**로 초기화됨

### (2) 실행 단계 (Execution Phase)

- 실제 코드가 순서대로 실행
- 변수에 값이 할당되고 함수가 호출됨

> “선언(Declaration)”은 미리 처리되지만,
> 
> 
> “할당(Assignment)”은 원래 위치에서 실행된다.
> 

---

## var / let / const / 함수 의 호이스팅 차이

| 선언 방식 | 호이스팅 | 초기값 | 선언 전 접근 | 스코프 단위 |
| --- | --- | --- | --- | --- |
| **var** | 됨 | `undefined` | 가능 (undefined) | 함수 스코프 |
| **let** | 됨 (TDZ 존재) | 없음 | ReferenceError | 블록 스코프 |
| **const** | 됨 (TDZ 존재) | 없음 | ReferenceError | 블록 스코프 |
| **function 선언문** | 전체 함수 | 함수 본문 전체 사용 가능 | 가능 | 함수 스코프 |
| **함수 표현식 (var)** | (변수만) | `undefined` | 실행 시 TypeError | 함수 스코프 |
| **함수 표현식 (let/const)** | (TDZ) | 없음 | ReferenceError | 블록 스코프 |

---

## 예시로 보는 차이

### (1) var의 호이스팅

```jsx
console.log(a); // undefined
var a = 10;

```

→ 실제로는 이렇게 처리됨:

```jsx
var a;          // 선언부 호이스팅
console.log(a); // undefined
a = 10;         // 할당

```

---

### (2) let / const의 호이스팅 (TDZ 존재)

```jsx
console.log(a); // ReferenceError
let a = 10;

```

→ 실제로는:

```jsx
// TDZ (Temporal Dead Zone)
let a; // 선언은 이미 인식됨 (호이스팅됨)
a = 10;

```

**선언은 위로 올라갔지만 접근 불가한 시기(TDZ)** 가 존재합니다.

→ 변수 선언 위치에 도달해야만 사용 가능.

---

### (3) 함수 선언문 vs 함수 표현식

```jsx
sayHello(); // OK
sayBye();   // TypeError

function sayHello() {
  console.log("Hello");
}

var sayBye = function() {
  console.log("Bye");
};

```

- **함수 선언문**: 전체 함수가 호이스팅되므로 선언 전 호출 가능
- **함수 표현식**: 변수만 호이스팅되고, 값(함수)은 나중에 할당 → undefined 상태에서 호출 시 에러

---

## 전역 vs 함수 스코프에서의 호이스팅

### 예시 1: 전역 변수

```jsx
console.log(x); // undefined
var x = 100;
```

→ 전역 컨텍스트의 **Variable Environment** 에서

선언이 미리 등록되어 `undefined` 로 초기화됨.

---

### 예시 2: 함수 내부 변수 (전역과 같은 이름)

```jsx
var x = 10;

function test() {
  console.log(x); // undefined 
  var x = 20;
  console.log(x); // 20
}
test();

```

설명:

- 함수 실행 시 새로운 **함수 실행 컨텍스트** 생성
- `var x` 선언이 **함수 스코프 내에서 호이스팅**
- 따라서 첫 번째 `console.log(x)`는 전역 `x`를 보지 않고,
    
    **함수 내부의 (아직 초기화만 된) x = undefined**를 참조
    

→ 이걸 **스코프 섀도잉(scope shadowing)** 이라고 해요.

내부 스코프에서 같은 이름으로 선언하면 외부 스코프의 변수를 “가립니다.”

---

## TDZ(Temporal Dead Zone) 정리

**TDZ**는 `let`, `const`가 선언되었지만 아직 “초기화되지 않은 상태”입니다.

선언문이 실행되기 전까지 접근하면 `ReferenceError` 발생.

예시:

```jsx
{
  console.log(a); // ReferenceError
  let a = 5;
  console.log(a); // 5
}

```

- 변수는 **이미 엔진에 의해 등록(호이스팅됨)** 되었지만,
    
    **TDZ 상태**라 접근 불가.
    
- TDZ는 **블록 단위**로 존재함.

---

## 호이스팅은 “스코프별로 독립적으로 발생”

- 전역 스코프, 함수 스코프, 블록 스코프 각각 별도로 일어남.
- 즉, “선언이 속한 스코프”의 맨 위로만 끌어올려짐.

```jsx
let a = 1;
function outer() {
  console.log(a); // 1? undefined? ReferenceError?
  var a = 2;
}
outer(); // undefined

```

이 경우:

- `var a` 가 함수 스코프 내부에서 호이스팅되어 **outer 스코프 내에서만 undefined로 초기화**
- 따라서 전역의 `a=1` 은 가려지고(섀도잉),
    
    **함수 내부의 var a 가 undefined 상태**로 참조됨.
    

---

## 핵심 요약 정리표

| 개념 | 설명 |
| --- | --- |
| **호이스팅** | 변수/함수 선언이 스코프 상단으로 끌어올려지는 것처럼 동작 |
| **범위** | 선언이 속한 스코프(전역, 함수, 블록) 내에서만 |
| **var** | 호이스팅 + undefined 초기화 (선언 전 접근 가능) |
| **let / const** | 호이스팅됨 + TDZ로 보호 (선언 전 접근 불가) |
| **함수 선언문** | 전체 함수가 호이스팅 (선언 전 호출 가능) |
| **함수 표현식** | 변수만 호이스팅, 값은 나중에 할당 (선언 전 호출 불가) |
| **스코프 섀도잉** | 내부 스코프의 같은 이름 변수는 외부 변수를 가림 |
| **TDZ** | 선언은 되었지만 초기화 전까지 접근 불가한 시기 |

---
