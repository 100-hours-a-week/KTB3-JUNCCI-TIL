# 📚 JS 핵심 개념 정리(v8 엔진)

---

#  <mark> V8 동작과정 정리 </mark>

---
<img width="814" height="413" alt="스크린샷 2025-11-19 오후 4 39 42" src="https://github.com/user-attachments/assets/c7f0177e-0b6b-4a3e-8d47-e3e9fd07e036" />


## **1. 소스 코드 입력 (Source Code Input)**

JS 코드는 처음에 “문자열(String)” 상태로 V8에 도착한다.

이 시점에서는 **코드의 의미는 아무것도 파악되지 않은 상태!!**

코드를 실행하기 위한 여러 분석/컴파일 과정이 앞으로 순차적으로 진행된다.

---

## **2. 파싱 (Parsing)**

JS 문자열을 엔진이 이해할 수 있는 구조로 바꾸는 단계.

파싱은 두 단계로 나눠진다.

---

### **2-1. 토큰화(Tokenizing, Lexical Analysis)**

문자열 코드를 **의미 단위(Token)** 로 끊는다.

### 예시

```jsx
return a + b;

```

→ 다음 토큰으로 분해됨

- `return` (키워드)
- `a` (식별자)
- `+` (연산자)
- `b` (식별자)
- `;` (구분자)

### 토큰화 과정 설명

- 공백, 줄바꿈 등은 무시되지만 위치 정보(line, column)는 저장
- 주석도 무시되지만 내부적으로는 필요시 AST에 Comment 노드로 참조됨
- 숫자, 문자열은 value를 기록한 Token으로 변환됨
- 예약어(keyword)와 식별자(identifier)는 Token 타입이 다름
- 예약어와 식별자 키워드 정리
    
    **1. Keyword(예약어)란?**
    
    ---
    
    > 언어에서 이미 의미가 정해져 있는 단어
    > 
    > 
    > → JavaScript 엔진이 특별한 기능 수행을 위해 미리 예약해놓은 단어들.
    > 
    
    ### 예:
    
    - `let`
    - `const`
    - `function`
    - `return`
    - `if`
    - `for`
    - `while`
    - `class`
    
    ### 특징:
    
    - **코드에서 특정 용도로만 사용 가능**
    - 변수명이나 함수명 같은 식별자로 사용할 수 없음
    - 파서(parser)가 이 단어를 보면 **특별한 문법 구조를 시작**한다고 판단함
    
    **2. Identifier(식별자)란?**
    
    ---
    
    > 개발자가 직접 이름을 붙이는 단어
    > 
    > 
    > → 변수명, 함수명, 클래스명, 객체 속성명 등
    > 
    
    ### 예:
    
    ```jsx
    let age = 10;
    function add(a, b) {}
    
    ```
    
    여기서
    
    - `age`
    - `add`
    - `a`
    - `b`
        
        → 모두 **Identifier**
        
    
    ### 특징:
    
    - **개발자가 자유롭게 이름을 설정**할 수 있음
    - 단, **keyword와 같은 이름은 사용할 수 없음**
    
    **Keyword와 Identifier의 Token 타입이 다른 이유**
    
    ---
    
    렉시컬 분석(Tokenizing)에서 엔진은 코드를 읽으며 **각 단어가 어떤 역할을 하는지** 결정해야 한다.
    
    ### ✔ Keyword는 문법의 구조를 만드는 역할
    
    예:
    
    - `function` 등장 → 함수 선언 문법 시작
    - `return` 등장 → 함수의 반환문
    - `if` 등장 → 조건문 시작
    
    엔진 입장에서 **keyword는 명확한 역할이 있음**.
    
    ---
    
    ### ✔ Identifier는 이름(name)을 의미
    
    엔진은 이를 보고
    
    - 변수인지
    - 함수인지
    - 파라미터인지
    - 객체 프로퍼티인지
        
        → 파싱 단계에서 판단하게 됨
        
    
    Identifier는 의미가 고정되어 있지 않고
    
    **문맥에 따라 의미가 달라짐**.
    
    ---
    

---

### **2-2. AST(Abstract Syntax Tree) 생성**

토큰을 JS 문법 규칙에 따라 구조적으로 분석하여 **트리(AST)** 로 만든다.

### 예를 들어:

```jsx
function add(a, b) { return a + b; }

```

AST의 계층 구조 예:

- 실습 과정
    
    ```jsx
    npm install acorn
    ```
    
    ```jsx
    import * as acorn from "acorn";
    
    const code = `
    function add(a, b) {
      return a + b;
    }
    `;
    
    const ast = acorn.parse(code, { ecmaVersion: 2020 });
    console.log(JSON.stringify(ast, null, 2));
    
    ```
    
    ```jsx
    junseopark@bagjunseoui-MacBookAir desktop % node ast.js              
    {
      "type": "File",
      "start": 0,
      "end": 40,
      "loc": {
        "start": {
          "line": 1,
          "column": 0,
          "index": 0
        },
        "end": {
          "line": 5,
          "column": 0,
          "index": 40
        }
      },
      "errors": [],
      "program": {
        "type": "Program",
        "start": 0,
        "end": 40,
        "loc": {
          "start": {
            "line": 1,
            "column": 0,
            "index": 0
          },
          "end": {
            "line": 5,
            "column": 0,
            "index": 40
          }
        },
        "sourceType": "module",
        "interpreter": null,
        "body": [
          {
            "type": "FunctionDeclaration",
            "start": 1,
            "end": 39,
            "loc": {
              "start": {
                "line": 2,
                "column": 0,
                "index": 1
              },
              "end": {
                "line": 4,
                "column": 1,
                "index": 39
              }
            },
            "id": {
              "type": "Identifier",
              "start": 10,
              "end": 13,
              "loc": {
                "start": {
                  "line": 2,
                  "column": 9,
                  "index": 10
                },
                "end": {
                  "line": 2,
                  "column": 12,
                  "index": 13
                },
                "identifierName": "add"
              },
              "name": "add"
            },
            "generator": false,
            "async": false,
            "params": [
              {
                "type": "Identifier",
                "start": 14,
                "end": 15,
                "loc": {
                  "start": {
                    "line": 2,
                    "column": 13,
                    "index": 14
                  },
                  "end": {
                    "line": 2,
                    "column": 14,
                    "index": 15
                  },
                  "identifierName": "a"
                },
                "name": "a"
              },
              {
                "type": "Identifier",
                "start": 17,
                "end": 18,
                "loc": {
                  "start": {
                    "line": 2,
                    "column": 16,
                    "index": 17
                  },
                  "end": {
                    "line": 2,
                    "column": 17,
                    "index": 18
                  },
                  "identifierName": "b"
                },
                "name": "b"
              }
            ],
            "body": {
              "type": "BlockStatement",
              "start": 20,
              "end": 39,
              "loc": {
                "start": {
                  "line": 2,
                  "column": 19,
                  "index": 20
                },
                "end": {
                  "line": 4,
                  "column": 1,
                  "index": 39
                }
              },
              "body": [
                {
                  "type": "ReturnStatement",
                  "start": 24,
                  "end": 37,
                  "loc": {
                    "start": {
                      "line": 3,
                      "column": 2,
                      "index": 24
                    },
                    "end": {
                      "line": 3,
                      "column": 15,
                      "index": 37
                    }
                  },
                  "argument": {
                    "type": "BinaryExpression",
                    "start": 31,
                    "end": 36,
                    "loc": {
                      "start": {
                        "line": 3,
                        "column": 9,
                        "index": 31
                      },
                      "end": {
                        "line": 3,
                        "column": 14,
                        "index": 36
                      }
                    },
                    "left": {
                      "type": "Identifier",
                      "start": 31,
                      "end": 32,
                      "loc": {
                        "start": {
                          "line": 3,
                          "column": 9,
                          "index": 31
                        },
                        "end": {
                          "line": 3,
                          "column": 10,
                          "index": 32
                        },
                        "identifierName": "a"
                      },
                      "name": "a"
                    },
                    "operator": "+",
                    "right": {
                      "type": "Identifier",
                      "start": 35,
                      "end": 36,
                      "loc": {
                        "start": {
                          "line": 3,
                          "column": 13,
                          "index": 35
                        },
                        "end": {
                          "line": 3,
                          "column": 14,
                          "index": 36
                        },
                        "identifierName": "b"
                      },
                      "name": "b"
                    }
                  }
                }
              ],
              "directives": []
            }
          }
        ],
        "directives": [],
        "extra": {
          "topLevelAwait": false
        }
      },
      "comments": []
    ```
    

```
FunctionDeclaration
├─ Identifier("add")
├─ params: [Identifier("a"), Identifier("b")]
└─ body: BlockStatement
   └─ ReturnStatement
      └─ BinaryExpression "+"
         ├─ Identifier("a")
         └─ Identifier("b")

```

### 파싱의 역할

- 스코프(전역/함수/블록) 분석
- 변수 선언/사용 위치 확인
- JS 문법 분석(함수, 조건문, 표현식, 블록)
- 실행 엔진에서 필요한 데이터 준비

이 AST는 **바이트코드 생성의 청사진**이 된다.

---

## **3. 인터프리터 단계 (Ignition)**

여기서부터 V8만의 진짜 엔진 로직이 시작된다.

Ignition은 **두 가지 역할**을 한다.

1. **AST → 바이트코드 컴파일러(Bytecode Compiler)**
2. **바이트코드 인터프리터(Bytecode Interpreter)**

---

### **3-1. AST → 바이트코드(Bytecode) 생성**

바이트코드란:

- JavaScript처럼 고수준도 아니고
- 기계어(native machine code)처럼 CPU가 직접 실행할 수도 없는
    
    **중간 수준의 실행 코드**
    

예시(개념적):

```
Lda a
Add b
Return

```

바이트코드 생성 시 Ignition이 수행하는 작업:

- 스코프 체인 생성
- 매개변수 / 로컬 변수 슬롯 구성
- 상수 테이블 구성(Constant Pool)
- 함수/메서드 내부의 클로저 정보를 연결
- 히든 클래스 생성의 기반 정보 수집
- IC(Inline Cache) 구조 준비

> 결과:
> 
> 
> JS → AST → 바이트코드로 완전히 변환된 상태.
> 

---

### **3-2. 바이트코드 실행 & 프로파일링 (Ignition Interpreter)**

Ignition은 생성된 바이트코드를 직접 해석 실행(interpret)한다.

바이트코드는 내부적으로 "가상 레지스터 기반" 구조이며,

Ignition은 이를 순차적으로 읽어 수행한다.

### 실행하면서 동시에 수행하는 핵심 작업:

### (1) **프로파일링 데이터 수집**

- 함수 호출 횟수
- 어떤 인자 타입이 들어오는지
- Hidden Class가 일정한지
- 특정 표현식이 얼마나 자주 실행되는지
- 프로퍼티 접근 패턴이 일관적인지

이 정보는 **TurboFan**에게 전달된다.

즉, TurboFan이 최적화하는 데 필요한 통계 데이터가 이때 쌓임.

### (2) Inline Cache(IC) 갱신

예:

```jsx
obj.x

```

이 한 줄도 운영체제에서 보면 “동적 객체 접근”이라 비용이 비싸다.

Ignition은 이 과정에서 **객체의 히든 클래스(Shape)** 를 기록하고

인라인 캐시를 업데이트함.

> IC가 안정적 → TurboFan의 최적화 기회 상승
> 
- IC 정리
    
    **Inline Cache(IC) — 왜 필요한가?**
    
    JS는 **동적 타입 언어**라서 다음과 같은 상황이 생김:
    
    ```jsx
    obj.x
    
    ```
    
    이 한 줄을 엔진이 실행하려면 실제 내부에서는 이런 질문들을 던져야 함:
    
    - obj가 어떤 타입인가?
    - x라는 프로퍼티가 존재하나?
    - 있다면 offset(메모리 위치)은 어디인가?
    - obj가 다른 구조로 바뀌었다면?
    - prototype chain에 있는 프로퍼티인가?
    
    **프로퍼티 하나 읽는 것도 매우 비싼 연산**이 된다
    
    (정적 타입 언어처럼 메모리 위치가 고정된 것이 아니기 때문).
    
    그래서 이 비용을 줄이기 위해 등장한 것이 **Inline Cache(IC)**.
    
    **핵심: IC는 “이전 실행에서 얻은 정보를 캐싱해서 다음 실행을 빠르게 하는 기능”**
    
    ---
    
    예를 들어 다음 코드를 반복 실행:
    
    ```jsx
    obj.x
    
    ```
    
    처음 실행할 때:
    
    - obj의 실제 구조(Shape)를 파악
    - x 프로퍼티의 메모리 offset 계산
    - 이 정보를 Inline Cache에 저장
    
    → 이후 다시 `obj.x`가 실행되면
    
    **같은 객체 Shape인지 확인 후**
    
    바로 해당 offset을 사용해서 초고속으로 접근 가능
    
    **Hidden Class(Shape)는 뭐지?**
    
    ---
    
    JS 객체는 C++ 클래스처럼 고정된 구조가 없다.
    
    하지만 V8은 **객체 구조를 추론하기 위해 내부적으로 Hidden Class(또는 Shape)** 를 만든다.
    
    예:
    
    ```jsx
    const obj = { x: 10, y: 20 };
    
    ```
    
    V8 내부에서는:
    
    - 프로퍼티 순서
    - 프로퍼티 이름
    - 메모리 레이아웃
    
    이 정보를 기반으로 **Shape(히든 클래스)** 를 만든다.
    
    Shape는 객체의 “구조 서명(signature)” 같은 것.
    
    **IC는 어떻게 업데이트되는가?**
    
    ---
    
    코드가 실행될 때:
    
    1. `obj.x` 실행
    2. V8이 obj의 Hidden Class를 확인
    3. x의 offset 위치 계산
    4. Inline Cache에 저장
    
    **중요한 점: “IC가 안정적이면 TurboFan 최적화를 받을 수 있다”**
    
    ---
    
    ### IC가 안정적이라는 뜻?
    
    - `obj.x` 접근 시, **항상 동일한 Shape(히든 클래스)** 를 가진 객체가 들어온다는 의미
    
    예:
    
    ```jsx
    for (...) {
      obj.x    // 항상 같은 구조의 obj
    }
    
    ```
    
    이럴 때:
    
    - Hidden Class가 계속 일치
    - Inline Cache도 계속 동일한 경로를 사용
    - 이를 **monomorphic IC** 라고 함
    
    → TurboFan이 매우 강력한 최적화를 적용할 수 있는 신호
    
    **한 줄 요약**
    
    ---
    
    **Inline Cache(IC)**
    
    → 프로퍼티 접근의 "이전 실행 결과"를 캐싱해서 빠르게 만드는 기술
    
    → Hidden Class(Shape)가 일치하면 극도로 빠른 최적화 가능
    
    → IC가 안정적이면 TurboFan이 최적화 기계어를 생성하는 데 유리함
    
    ---
    

---

## **4. JIT 컴파일러 단계 (TurboFan)**

핵심: **자주 실행되는 코드만** 최적화하여 기계어(native code)로 컴파일한다.

---

### **4-1. Hot Code 감지**

Ignition이 수집한 데이터를 바탕으로:

- 호출 횟수가 많은 함수
- 루프가 반복 실행되는 코드
- 타입 패턴이 일정한 연산

을 “핫 코드”라고 분류한다.

이제 V8은 판단한다:

> “이 코드는 계속 실행될 거니까, 기계어로 변환해도 투자 가치가 있다.”
> 

---

### **4-2. TurboFan 최적화 컴파일 과정**

TurboFan은 바이트코드 + 프로파일 정보를 기반으로

아주 복잡한 최적화를 수행한다.

### TurboFan 주요 최적화들

1. **타입 기반 최적화**
    - “이 값은 항상 number다” 같은 **타입 가정(assumption)** 을 세우고 그 가정이 맞는다는 전제하에 **타입 체크를 제거**하고 불필요한 변환(박싱/언박싱)도 제거한다.
2. **인라이닝(Inlining)**
    - 작은 함수 호출을 아예 본문으로 펼쳐버림 → 속도 증가
    
    ```jsx
    function add(x, y) { return x + y; }
    
    function calc(n) {
      return add(n, 10); // → n + 10 으로 본문이 직접 대체됨
    }
    ```
    
3. **루프 최적화 (Loop-invariant hoisting)**
    - 루프 내에서 반복 계산 제거
    
    ```jsx
    for (let i = 0; i < arr.length; i++) {
      total += arr.length;  // ← 루프마다 arr.length 계산 X
    }
    
    ```
    
    TurboFan이 최적화:
    
    ```jsx
    const len = arr.length;
    for (let i = 0; i < len; i++) {
      total += len;
    }
    
    ```
    
4. **불필요 연산 제거 (DCE)**
    - 영향을 주지 않는 코드 제거
5. **객체 레이아웃 최적화**
    - 히든 클래스 기반으로 빠른 프로퍼티 접근
6. **표현식 최적화**
    - 상수 folding
    
    상수끼리의 계산을 미리 해두는 것”
    
    예:
    
    ```jsx
    let x = 10 * 20;
    
    ```
    
    여기서 `10`과 `20`은 **상수(literal)** 이므로
    
    코드를 실행할 때 계산할 필요가 없음.
    
    그래서 컴파일러(TurboFan)가 미리 계산해서:
    
    ```
    10 * 20 → 200
    
    ```
    
    기계어 코드에서는:
    
    ```jsx
    let x = 200;
    
    ```
    
    처럼 들어감.
    
    - Common Subexpression Elimination(CSE) - 중복되는 동일 계산은 한 번만 계산하도록 최적화.

모든 최적화를 거쳐 **기계어(natively executable code)** 가 생성된다.

---

### **4-3. 디옵티마이즈(Deoptimize)**

속도를 위해 TurboFan은

“이 코드는 이런 식으로 사용될 것이다”라는 **가정(assumption)** 을 기반으로 최적화한다.

예:

```jsx
sum(1);
sum(2);
sum("3"); // 가정 파괴!

```

x가 항상 number일 거라 믿고 최적화한 상태에서

string이 들어오면:

> “가정이 깨졌다 → 지금 최적화 코드로는 실행 불가”
> 

TurboFan 코드는 **버려지고**,

Ignition 인터프리터로 다시 돌아간다.

(되돌아가는 과정은 매우 복잡한 프레임 재구성 작업 수행)

---

## **5. 실행 (Execution)**

![image.png](attachment:68283813-d556-4785-809b-254e75f68f23:image.png)

### 1️⃣ Call Stack (콜 스택)

JS가 실제로 실행되는 공간

- 함수 실행
- 동기 코드 처리
- 실행이 끝나면 스택에서 pop

---

### 2️⃣ Web APIs (브라우저가 제공하는 비동기 기능)

JS 엔진이 직접 처리 불가능한 작업을 브라우저가 대신 처리

- Timer
- Fetch
- DOM Events
- setTimeout / setInterval
- File I/O

비동기 작업이 완료되면 콜백을 Task Queue로 보냄.

---

### 3️⃣ Task Queues (태스크 큐)

### **Microtask Queue**

- Promise.then
- async/await
- MutationObserver
- 가장 우선순위 높음

### **Macrotask Queue**

- setTimeout
- setInterval
- DOM 이벤트 콜백
- I/O callback

---

### 4️⃣ Event Loop

> "Call Stack이 비었는지 체크한 뒤,
> 
> 
> Task Queue에서 작업을 꺼내 Stack으로 전달하는 심장(PUMP) 역할."
> 

순서:

1. 스택이 비면
2. Microtask Queue 먼저 실행
3. 없으면 Macrotask Queue 실행
4. 다시 반복

---

## 전체 실행 흐름

1. JS 코드 실행 → Call Stack
2. 비동기 요청 발생 → Web API로 이동
3. Web API에서 처리 후 → Task Queue로 이동
4. Event Loop가 스택이 비면 Queue에서 하나 꺼냄
5. 다시 Call Stack으로 실행
6. 반복

---

## **6. 가비지 컬렉션(Garbage Collection)**

**가비지 컬렉션이란?**

---

> 더 이상 사용되지 않는 객체(메모리)를 자동으로 찾아 제거하는 시스템.
> 

JavaScript는 메모리를 직접 해제할 수 없기 때문에

V8 엔진이 **자동으로 메모리를 정리**해준다.

JavaScript는 자동 메모리 관리 언어이기 때문에

개발자가 `free()` 같은 것을 직접 호출하지 않아.

GC가 알아서:

- 누가 사용 중인 메모리인지
- 누가 더 이상 필요 없는지

판단하고 해제한다.

**V8의 GC 구조 개요**

---

V8의 힙(Heap)은 크게 두 세대로 나뉜다:

1. **Young Generation**
    - 새로 만들어진 객체가 저장됨
    - 크기가 작고, 수명이 짧은 객체가 대부분
    - 정리 속도가 매우 빠른 알고리즘 사용
2. **Old Generation**
    - 오래 살아남은 객체들이 이동되는 영역
    - 크기가 큼
    - 더 복잡한 알고리즘으로 정리

왜 두 개로 나뉠까?

→ 대부분의 JS 객체는 **빨리 생성되고 빨리 사라지기 때문!** 

- 왜 빨리 생성되고 빨리 사라지기 때문
    
    
    **왜 JS 객체는 “빨리 생성되고 빨리 사라지는가?”**
    
    ---
    
    JavaScript의 실행 패턴 특성 때문이다.
    
    **1. 함수가 많고, 함수 호출이 잦다**
    
    JS는 함수 기반 언어라서:
    
    ```jsx
    function foo() {
      const temp = { value: 10 };
      return temp.value;
    }
    
    ```
    
    - `temp` 같은 객체는 **함수가 끝나면 바로 생명 주기가 끝난다**.
    - **짧은 생명(lifetime) 객체**가 매우 많이 생성됨.
    
    **2. 이벤트 기반 언어라 “짧은 생명 객체”가 반복적으로 생성**
    
    ---
    
    예:
    
    ```jsx
    button.addEventListener("click", () => {
      const data = { clicked: true };
    });
    
    ```
    
    - 클릭 할 때마다 data 객체 새로 생성
    - 그러나 이벤트 핸들러 수행이 끝나면 대부분의 객체는 사라짐
    
    → “짧게 살아서 금방 죽는 객체”가 폭발적으로 많이 만들어짐.
    
    ---
    
    **3. 반복문 안에서 값이 계속 새로 생겨남**
    
    ```jsx
    for (let i = 0; i < 1000; i++) {
      const obj = { x: i };
    }
    
    ```
    
    - 여기서 obj는 매 루프마다 곧바로 사라짐
    - 메모리의 **단기 객체 폭주 패턴**
    
    ---
    
    **4. 중간 계산을 위한 임시 객체(temporary object)가 매우 많음**
    
    예:
    
    ```jsx
    const result = arr.map(v => v * 2);
    
    ```
    
    `.map` 안에서
    
    - callback
    - return value
    - 중간 계산
        
        → 모두 짧은 생명 객체들을 만들어냄.
        
    
    ---
    

세대별로 최적화된 알고리즘을 적용하면 전체 성능이 훨씬 좋아진다.

---

**Young Generation – Scavenge (Copying GC)**

> “살아 있는 것만 빠르게 복사하고, 나머지 버리는 방식.”
> 

이 알고리즘은 다음 방식으로 동작한다:

- Young 영역은 두 개의 공간(Semi-space)으로 구성됨
    - From-space
    - To-space
- GC가 실행되면
    - **살아 있는 객체만 To-space로 복사**
    - 나머지는 버림
- 끝나면 To-space가 새로운 From-space가 됨

### 장점

- 매우 빠름 ("copying GC"라서 속도가 터짐)
- Young generation에서 사용하는 이유

### 단점

- 매번 공간을 복사해야 하므로,
    
    큰 객체에는 부적합 → 그래서 큰 객체는 바로 Old Gen에 들어가기도 함
    

---

**Old Generation – Mark-Sweep / Mark-Compact**

Young Gen에서 오래 살아남은 객체는 Old Gen으로 이동한다.

Old Gen은 크기가 매우 크기 때문에

더 정교한 알고리즘이 필요하다.

**Mark Phase (표시 단계)**

> 살아있는(object reachable) 객체들을 찾아서 “mark 표시”
> 
- Root(전역 객체, 스택 등)에서 시작하여
- 객체를 따라가며 접근 가능한 것들을 모두 mark

**Sweep Phase (정리 단계)**

> mark되지 않은 객체를 제거하여 메모리를 비움
> 

→ 이게 **Mark-Sweep**

---

**Mark-Compact (조각 모음)**

Mark-Sweep은 메모리 조각(fragmentation)이 생길 수 있다.

이를 해결하기 위해:

> 살아있는 객체를 메모리 한쪽으로 몰아서 정렬(compact)
> 

장점:

- 메모리 파편화 감소
- 이후 할당하기 좋아짐

단점:

- 시간이 오래 걸릴 수 있음

---

**V8 GC는 멈춤(pause)을 최소화하기 위해 "Incremental" & "Concurrent" 기술 사용**

JS 실행이 멈추는 걸 개발자가 싫어하기 때문에,

V8은 최신 기술을 많이 사용한다.

### ✔ Incremental Marking

- 마킹을 한꺼번에 하지 않고
- 작은 덩어리로 나눠 여러 번 수행
    
    → “Stop-the-world” pause 시간 최소화
    

### ✔ Concurrent Marking

- GC가 JS 실행과 **동시에 진행**되기도 함
    
    → 멈춤 거의 없음
    

### ✔ Idle-time GC

- 브라우저가 쉬는 시간에 몰아서 GC 실행
    
    → 사용자 체감 멈춤 방지
