# 📚 React 핵심 개념 정리()

---

# <mark> LifeCycle </mark> 

React 컴포넌트는 **<mark> 생성(Mounting) → 업데이트(Updating) → 제거(Unmounting)</mark>** 흐름을 거치며, 이 과정 전체를 **라이프사이클**이라고 한다.

라이프사이클마다 호출되는 **특정 메서드 또는 Hook**이 존재하며 컴포넌트가 화면에서 어떻게 동작하는지를 제어할 수 있다.

### **1) Mount (컴포넌트가 처음 화면에 나타날 때)**

컴포넌트가 **처음 렌더링되어 DOM에 붙는 순간**.

- 사용자가 페이지에 처음 접속했을 때
- 조건부 렌더링으로 기존에 없던 컴포넌트가 새로 생겼을 때
- React는 컴포넌트 함수를 실행 → JSX 생성 → 가상 DOM 구성 → 실제 DOM에 반영

 `useEffect(() => { ... }, [])` 이 시점에 동작.

---

## 2️⃣ Update (화면에 있는 컴포넌트가 다시 렌더링될 때)

이미 화면에 있는 컴포넌트가 **새로운 데이터로 다시 렌더링되는 순간**이에요.

Update가 일어나는 경우:

- 부모 컴포넌트가 새로운 props를 내려줄 때
- 컴포넌트 내부 state가 변경될 때 (`useState`)
- Context 값이 수정될 때
- 강제로 업데이트를 트리거할 때(rare)

React는 변화된 데이터 기반으로 **리렌더링을 수행**하고, 이전 가상 DOM과 비교해 변경된 부분만 실제 DOM에 반영.

`useEffect(() => { ... }, [deps])` 에서 deps가 바뀌면 이 시점에 실행.

---

## 3️⃣ Unmount (화면에서 완전히 사라질 때)

컴포넌트가 **DOM에서 제거되는 순간**을 말해요.

- 페이지 이동
- 조건부 렌더링에서 `false`가 되어 컴포넌트가 삭제
- 사용자 행동으로 탭을 닫는 경우 등

Unmount 시점에는 정리(clean-up)가 필요할 수 있음

(ex. 이벤트 제거, 타이머 clear, 구독 해제 등)

`useEffect` return 함수가 이 시점에 실행

```jsx
useEffect(() => {
  return () => {
    // cleanup: unmount 시 실행
  };
}, []);

```

---

## 1️⃣ Mounting 단계 (컴포넌트가 화면에 처음 나타날 때)

**순서:**

`constructor → getDerivedStateFromProps → render → componentDidMount`

### 1. constructor(props)

- **가장 먼저 한 번만 실행**
- state 초기화, 메서드 바인딩 용도로 사용
- Side Effect(데이터 요청 등) 금지

```jsx
constructor(props) {
  super(props);
  this.state = { count: 0 };
}
```

---

### 2. static getDerivedStateFromProps(props, state)

- 렌더링 직전마다 호출됨
- props로부터 state를 동기화해야 할 경우 사용
- side-effect 금지
- 매우 드물게 사용

```jsx
static getDerivedStateFromProps(nextProps, prevState) {
  if (nextProps.value !== prevState.value) {
    return { value: nextProps.value };
  }
  return null;
}

```

---

### 3. render()

- 화면에 보여줄 UI를 정의
- 반드시 순수함수여야 함
    
    (state 변경, side-effect 금지)
    

---

### 4. componentDidMount()

- 컴포넌트가 화면에 나타난 직후 1회 실행
- 실제 DOM에 접근 가능
- 네트워크 요청(API), 이벤트 등록 등 **s**ide-effect 수행 가능

```jsx
componentDidMount() {
  fetch('/api/data').then(...);
}

```

---

## Mounting 단계에서 대응되는 Hook

| Class Method | Hook |
| --- | --- |
| constructor | useState 초기값 |
| componentDidMount | useEffect(() => {}, []) |

---

## Updating 단계 (state 또는 props가 바뀔 때)

**순서:**

`getDerivedStateFromProps → shouldComponentUpdate → render → getSnapshotBeforeUpdate → componentDidUpdate`

---

### 1. static getDerivedStateFromProps(props, state)

- Mounting과 동일하게 렌더 전 호출

---

### 2. shouldComponentUpdate(nextProps, nextState)

- 리렌더링 여부를 스스로 결정
- 성능 최적화 용도

```jsx
shouldComponentUpdate(nextProps, nextState) {
  return nextState.value !== this.state.value;
}

```

---

### 3. render()

- UI 재렌더링

---

### 4. getSnapshotBeforeUpdate(prevProps, prevState)

- DOM 업데이트 직전 호출
- 스크롤 위치 등 DOM 변경 전 정보를 기록하는 데 유용

```jsx
getSnapshotBeforeUpdate(prevProps, prevState) {
  return this.listRef.scrollHeight;
}

```

---

### 5. componentDidUpdate(prevProps, prevState, snapshot)

- DOM 업데이트 후 호출
- snapshot 사용 가능
- 데이터 재요청 등 side-effect 허용
- 단, 상태 갱신 시 조건문으로 무한루프 방지 필수

```jsx
componentDidUpdate(prevProps) {
  if (prevProps.id !== this.props.id) {
    this.fetchData();
  }
}

```

---

## Updating 단계에서 대응되는 Hook

| Class Method | Hook |
| --- | --- |
| shouldComponentUpdate | React.memo / useMemo / useCallback |
| componentDidUpdate | useEffect(() => { ... }) |
| getSnapshotBeforeUpdate | useLayoutEffect 일부 역할 가능 |

---

## Unmounting 단계 (컴포넌트가 화면에서 사라질 때)

### componentWillUnmount()

- 컴포넌트가 제거되기 직전에 실행
- 이벤트 제거 / 타이머 정리 / 구독 해제(clean-up) 등에 사용

```jsx
componentWillUnmount() {
  window.removeEventListener('resize', this.handleResize);
}

```

---

## Unmounting 단계에서 대응되는 Hook

| Class Method | Hook |
| --- | --- |
| componentWillUnmount | useEffect의 clean-up 함수 |

```jsx
useEffect(() => {
  window.addEventListener('resize', handler);

  return () => {
    window.removeEventListener('resize', handler); // unmount 시 실행
  }
}, []);

```

---

## Deprecated(더 이상 사용 X) 라이프사이클

React 16.3 이후 **UNSAFE_** prefix가 붙고 사용 비권장됨.

| 이전 메서드 | 비고 |
| --- | --- |
| componentWillMount | 사용 금지 |
| componentWillReceiveProps | getDerivedStateFromProps로 대체 |
| componentWillUpdate | 사용 금지 |

> 새로운 프로젝트에서는 사용하지 않는 것이 권장됨.
> 

---

## Hooks 시대의 관점에서 본 라이프사이클

함수형에서는 별도의 라이프사이클 함수가 없고,

**useEffect가 Mount/Update/Unmount 모두 담당**한다.

| 상황 | Hook |
| --- | --- |
| Mount 시 1회 | useEffect(() => { ... }, []) |
| Update 시 | useEffect(() => { ... }) |
| Unmount 시 | useEffect(() => { return () => {...} }, []) |

---

# <mark> Hooks </mark>

### 정의

> Hook은 함수형 컴포넌트에서 state와 라이프사이클 기능을 연동해 주는 함수.
> 
> 
> 클래스 컴포넌트에서만 가능하던 상태 관리, 생명주기 제어를 함수형에서도 가능하게 만든 것. ([React](https://legacy.reactjs.org/docs/hooks-reference.html?utm_source=chatgpt.com))
> 
- `useState` → this.state, this.setState 없이 상태 사용
- `useEffect` → componentDidMount / DidUpdate / WillUnmount 역할
- `useContext` → contextType, Consumer 없이 컨텍스트 사용

### 왜 도입됐는지 (간단 이유)

- 클래스 컴포넌트의 복잡한 this, 라이프사이클 분산 문제
- 상태 로직 재사용이 어려움(HOC, render props 남발)
- 함수형 컴포넌트도 “일급 시민”으로 만들기 위해
    
    ([UXPin](https://www.uxpin.com/studio/blog/react-hooks/?utm_source=chatgpt.com))
    

---

## 기본 Hooks

### `useState` – 상태(state) 관리

**정의**

컴포넌트에 “상태 변수” 하나를 추가하는 Hook. ([React](https://react.dev/reference/react/useState?utm_source=chatgpt.com))

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0); // 초기값 0

  return (
    <div>
      <p>현재 값: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}

```

- `count` : 현재 상태 값
- `setCount` : 상태를 바꾸는 함수
- `useState(initialState)` : 처음 렌더링될 때만 initialState 사용, 그 이후에는 무시됨 ([React](https://react.dev/reference/react/useState?utm_source=chatgpt.com))

**특징**

- setState를 호출하면 → 상태 변경 → 컴포넌트가 다시 렌더링
- 상태 업데이트는 비동기이며, 여러 번 호출되면 React가 배치 처리

---

### `useEffect` – 사이드 이펙트(부수효과) 관리

**정의**

컴포넌트를 **외부 시스템과 동기화**하기 위한 Hook.

(네트워크 요청, 이벤트 리스너, DOM 조작, 로그 등) ([React](https://react.dev/reference/react/useEffect?utm_source=chatgpt.com))

```jsx
import { useEffect, useState } from "react";

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // Mount 또는 userId 변경 시 실행
    async function load() {
      const res = await fetch(`/api/users/${userId}`);
      const data = await res.json();
      setUser(data);
    }
    load();

    // cleanup (옵션)
    return () => {
      // 구독 해제, 타이머 정리 등
    };
  }, [userId]); // 의존성 배열
}

```

**동작 방식** ([React](https://react.dev/reference/react/useEffect?utm_source=chatgpt.com))

- 의존성 배열이 `[]` → Mount 때 1번 + StrictMode 환경에서 개발 시 2번 호출 가능
- `[userId]` → userId가 바뀔 때마다 실행
- 없으면 (`useEffect(fn)`) → 매 렌더링마다 실행
- return으로 넘긴 함수는 **cleanup**:
    - unmount 시
    - 다음 effect 실행 직전에 실행

---

### `useContext` – 전역/공유 상태 읽기

**정의**

React Context를 함수형 컴포넌트에서 쉽게 읽게 해주는 Hook. ([React](https://legacy.reactjs.org/docs/hooks-reference.html?utm_source=chatgpt.com))

```jsx
const ThemeContext = createContext("light");

function Button() {
  const theme = useContext(ThemeContext); // "light" 또는 "dark"
  return <button className={theme}>버튼</button>;
}

function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Button />
    </ThemeContext.Provider>
  );
}

```

- props drilling 없이 하위 컴포넌트에서 값 바로 접근
- Redux, Zustand 같은 전역 상태 관리 라이브러리와도 함께 쓸 수 있음

---

## `useReducer` – 복잡한 state 로직 관리

**정의**

여러 상태를 한 번에 관리하거나, 상태 전이가 복잡할 때 사용.

Redux의 reducer 패턴과 거의 동일. ([React](https://legacy.reactjs.org/docs/hooks-reference.html?utm_source=chatgpt.com))

```jsx
function reducer(state, action) {
  switch (action.type) {
    case "increment": return { count: state.count + 1 };
    case "decrement": return { count: state.count - 1 };
    default: return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <>
      <p>{state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+1</button>
    </>
  );
}

```

- 상태 변화 로직을 컴포넌트 밖으로 분리해서 코드 구조가 깔끔해짐
- 여러 필드를 가진 복합 state에 좋음 (ex. form, wizard 등)

---

### `useMemo` – 계산 결과 메모이제이션

**정의**

비싼 계산 결과를 **캐싱**해서, 의존성이 안 바뀌면 다시 계산하지 않게 해주는 Hook. ([React](https://react.dev/reference/react/useMemo?utm_source=chatgpt.com))

```jsx
const filteredList = useMemo(() => {
  return heavyFilter(list, keyword); // 비용 큰 계산
}, [list, keyword]);

```

- `heavyFilter`가 비싸고, list/keyword가 안 바뀌면 이전 결과 재사용
- 성능 최적화용. “무조건 쓰기”가 아니라 **비용이 큰 연산에만** 사용해야 효과적

---

### `useCallback` – 함수 메모이제이션

**정의**

함수 정의 자체를 캐싱해서, 매 렌더마다 새 함수가 생성되는 문제를 줄이는 Hook. ([React](https://react.dev/reference/react/useCallback?utm_source=chatgpt.com))

```jsx
const handleClick = useCallback(() => {
  doSomething(id);
}, [id]);

```

**언제 쓰냐**

- 자식 컴포넌트가 `React.memo` 또는 `useEffect`로 props의 “참조 동일성”을 신경쓸 때
- 함수가 자식에게 내려갔는데, 매번 새로 만들어져서 불필요한 리렌더를 유발하는 경우

> React 19 / React Compiler에서는 useCallback/useMemo 사용 빈도를 줄이는 방향으로 가고 있지만, 지금은 여전히 많이 사용됨. (React)
> 

---

### `useRef` – DOM 참조 & mutable 값 보관

**정의**

렌더링과 상관없는 “변하는 값”을 저장하는 상자 같은 Hook.

- DOM 요소 접근
- 이전 값 저장
- 타이머 ID 저장 등

```jsx
const inputRef = useRef(null);

useEffect(() => {
  inputRef.current.focus(); // DOM 요소 직접 접근
}, []);

return <input ref={inputRef} />;

```

**특징**

- `.current`에 있는 값은 바뀌어도 렌더링을 트리거하지 않음
- “렌더와 무관한 값”을 저장하기에 적합

---

### 그 외 자주 보이는 Hooks

React 공식 내장 Hooks들: ([React](https://react.dev/reference/react/hooks?utm_source=chatgpt.com))

- `useLayoutEffect` : 레이아웃 계산 직후, 화면 그리기 전에 동기 실행되는 Effect
- `useImperativeHandle` : forwardRef와 함께, 부모에서 노출할 인스턴스 제어
- `useId` : 서버/클라이언트에서 충돌 없는 고유 ID 생성
- `useTransition`, `useDeferredValue` : 긴 렌더링 작업을 부드럽게 처리하기 위한 동시성 관련 Hook
- `useSyncExternalStore`, `useInsertionEffect` : 라이브러리 구현자용 (상태구독, CSS-in-JS 등)

---

## Hooks 사용할 때 반드시 지켜야 하는 규칙

공식 문서에서 강조하는 두 가지 규칙: ([위키백과](https://en.wikipedia.org/wiki/React_%28software%29?utm_source=chatgpt.com))

1. **최상위에서만 Hook을 호출할 것**
    - 반복문, 조건문, 중첩 함수 안에서 호출 ❌
    - 항상 컴포넌트 함수의 최상위 레벨에서만 호출
    - 이유: 렌더마다 Hook이 **항상 같은 순서로 호출**되어야 React가 어떤 state가 어떤 Hook 것인지 매칭할 수 있음
2. **React 함수(컴포넌트, 커스텀 Hook)에서만 호출할 것**
    - 일반 함수, 클래스 메서드, 이벤트 핸들러 바깥에서 호출 ❌
    - `function MyComponent()`, `function useMyHook()` 내부에서만 호출

ESLint 플러그인(`eslint-plugin-react-hooks`)을 쓰면 이 규칙을 자동으로 체크해 줘서, 실수 방지에 도움 됨.

---

## 1) 리액트는 “현재 렌더링 중인 컴포넌트”를 알고 있다

React는 매 렌더링마다 **현재 어떤 컴포넌트 함수가 실행 중인지** 추적한다.

그리고 그 컴포넌트를 위해 별도의 메모리 공간(배열/연결 리스트 형태)을 내부에 만들어둔다.

---

## 2) 훅은 **순서 기반(Hook Order)** 으로 저장된다

### ✔ 동작 원리

1. 컴포넌트가 렌더링을 시작하면 React는 “훅 인덱스”를 0으로 초기화한다.
2. 첫 번째 `useState()` → 메모리 공간의 0번 칸에 연결
3. 두 번째 `useState()` → 1번 칸에 연결
4. 세 번째 `useState()` → 2번 칸에 연결 …

다시 렌더링이 일어나면:

- 인덱스는 0부터 다시 시작
- 첫 번째 호출은 0번칸,
- 두 번째 호출은 1번칸 …

➡ **변수명은 중요하지 않고 ‘훅이 호출된 순서’가 상태를 결정한다.**

그래서 훅을 조건문 내부에 넣으면 안 되는 이유가 바로 이것.

---

## 3) 상태(state)가 렌더링 사이에서 유지되는 이유

컴포넌트 함수는 매 렌더링마다 새로 실행되지만,

**state 값은 컴포넌트 함수 바깥의 React 내부 메모리 공간에 저장**되어 있다.

`useState`가 반환하는 state와 setState 함수는

그 저장된 메모리 칸을 계속 참조하기 때문에:

- 컴포넌트 함수는 새로 실행되지만
- **메모리 공간에 기록된 최신 상태값은 유지된다**

➡ 클로저 + React의 외부 저장 구조로 상태가 이어지는 것.

---

## 4) 리액트 렌더링 과정은 2단계

React의 렌더링은 **Render Phase** → **Commit Phase** 로 나뉜다.

---

## **① Render Phase (계산 단계)**

컴포넌트 **함수 실행** 단계.

React는 이 phase 동안:

- 어떤 UI를 그릴지 계산
- JSX 생성
- useState 초기값 계산
- useMemo 연산 수행
- `return <JSX>` 수행

특징

- **순수해야 한다.**
    
    (렌더링 도중 서버 요청이나 DOM 조작 같은 부작용이 있으면 안 됨)
    
- UI 계산만 하고 **화면에는 아직 아무것도 반영하지 않는다.**

---

## **② Commit Phase (반영 단계)**

Render Phase에서 계산된 결과를

**실제 DOM에 적용하는 단계**.

- 가상 DOM diff → 실제 DOM 반영
- 브라우저가 화면을 실제로 그리기(paint)

화면이 이때 비로소 보인다.

---

## 5) 그럼 useEffect는 언제 실행될까?

**Commit Phase가 끝난 뒤, 화면이 실제로 그려지고 난 후 실행된다.**

1. 화면이 사용자에게 먼저 보인다
2. 그 다음 useEffect 내부 함수가 실행된다

왜 이렇게 설계되었나?

- useEffect 안에는 보통 “무거운 작업”이 들어오기 때문
    - 서버 요청
    - DOM 조작
    - 이벤트 등록
    - 타이머
- 이런 작업을 렌더링 도중에 실행하면 화면이 버벅거릴 수 있음
- 그래서 React는 **“화면 먼저 보여주고 → 나중에 작업 실행”** 구조를 사용

➡ useEffect는 “지금 실행”이 아니라

**나중에 특정 시점에 실행하라고 예약하는 훅**이라고 보면 된다.

---
