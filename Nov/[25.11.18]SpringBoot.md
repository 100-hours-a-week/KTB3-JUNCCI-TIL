# 📚 Spring Boot 핵심 개념 정리(Spring Security 개념)

---

# **<mark>Spring Security</mark>** 

---

### 1. Spring Security가 필요한 이유

보안 기능은 “당연히 존재해야 하지만, 직접 구현하면 너무 복잡하다.”

직접 구현하려면 다음을 모두 해결해야 한다:

* 비밀번호 암호화
* 로그인/로그아웃 처리
* 세션 고정 공격(Session Fixation) 방지
* CSRF 방어
* XSS 방어
* CORS 처리
* 인가 정책(Role/Authority 관리)
* 필터 기반 요청 차단

➡️ **Spring Security는 이 모든 기능을 규약 기반으로 통합 제공**.
단 몇 줄의 설정으로 높은 수준의 보안을 적용할 수 있음.

---

### 2. 보안 아키텍처 핵심 구성요소

Spring Security는 **필터 기반(Filters) 보안 구조**.

```
[브라우저 요청]
     ↓
[서블릿 필터 체인]
     ↓
[DelegatingFilterProxy]
     ↓
[FilterChainProxy]
     ↓
[SecurityFilterChain]
     ↓
[각종 인증/인가 필터들]
     ↓
[DispatcherServlet]
```

요청은 DispatcherServlet에 도달하기 전 이미
**Spring Security의 필터 체인에서 강력하게 검사**.

---

### 3. DelegatingFilterProxy → FilterChainProxy → SecurityFilterChain

## DelegatingFilterProxy

* Servlet 필터
* Spring 컨테이너 내부의 보안 Bean들에게 필터 로직을 위임
* 서블릿 환경과 Spring Bean 환경을 연결하는 **브리지**

## FilterChainProxy

* 하나 이상의 `SecurityFilterChain`을 관리하는 **보안 관리자**
* URL 패턴에 따라 적절한 FilterChain 선택

## SecurityFilterChain

보안 필터들의 “리스트(체인)”.
예시 필터들:

* `CsrfFilter`
* `UsernamePasswordAuthenticationFilter`
* `LogoutFilter`
* `AuthorizationFilter`
* `SecurityContextHolderFilter`
* 기타 수십 개의 필터들

요청은 이 체인을 모두 통과해야 다음 단계로 넘어감.

---

### 4. 인증(Authentication) 흐름 완전 분석

Spring Security 인증 흐름은 다음과 같이 동작합니다:

```
POST /login
   ↓
UsernamePasswordAuthenticationFilter
   ↓   (ID/PW 추출 → 인증 전 Authentication 생성)
(Authentication: unauthenticated)
   ↓
AuthenticationManager
   ↓
DaoAuthenticationProvider
   ↓
  ① UserDetailsService.loadUserByUsername()
  ② PasswordEncoder.matches()
(Authentication: authenticated)
   ↓
SecurityContextHolder 저장
   ↓
세션에도 저장(Session 기반)
   ↓
이후 요청은 인증 상태가 유지됨
```

**Keyword 요약**

* `UsernamePasswordAuthenticationFilter`: 로그인 요청 감시
* `UserDetailsService`: 사용자 조회
* `PasswordEncoder`: 비밀번호 검증
* `SecurityContextHolder`: 인증 정보 저장소

---

### 5. 인가(Authorization) 흐름 완전 분석

“이 URL을 요청한 사용자가 접근 권한이 있는가?”를 판단하는 과정

```
요청
 ↓
AuthorizationFilter
 ↓
AuthorizationManager
   ├─ URL 패턴 매칭
   └─ Authentication(권한 정보) 검사
 ↓
AccessDecision
   ├─ 허용 → 다음 필터
   └─ 거부 → 403 Forbidden
```

* 인증(Authentication)은 “누구냐?”
* 인가(Authorization)는 “할 수 있냐?”

---

### 6. SecurityContextHolder & ThreadLocal

Spring Security는 인증 완료된 사용자 정보를
**요청 처리 중 어디서든 꺼내 쓸 수 있도록** 저장.

기본 전략 = **ThreadLocal**

### 특징

* 요청 1개 = 스레드 1개
* 스레드 내부에서만 접근 가능한 “사용자 정보 저장 공간”
* 요청 종료 후 자동 정리됨

### 사용자 정보 꺼내기

```java
Authentication auth = SecurityContextHolder.getContext().getAuthentication();
String username = auth.getName();
```

---

### 7. 세션 기반 vs JWT 기반 인증 비교

| 구분       | 세션 기반 인증   | JWT 기반 인증            |
| -------- | ---------- | -------------------- |
| 서버 저장 정보 | 세션 저장 필요   | 없음 (완전 Stateless)    |
| 확장성      | 낮음         | 매우 높음 (MSA 적합)       |
| 구현 난이도   | 쉬움         | 비교적 복잡               |
| 주요 위험    | 세션 하이재킹    | 토큰 탈취                |
| 로그아웃 처리  | 서버에서 세션 삭제 | Blacklist / 만료 전략 필요 |

> JWT를 사용해도 SecurityContextHolder는 동일하게 사용됨
> 단지 **매 요청마다 토큰에서 정보를 추출하여 다시 채워 넣는 방식**

---

### 8. CORS 완전 이해 + Preflight

### SOP(Same-Origin Policy)

브라우저는 다른 Origin에 요청할 때 보안을 위해 차단.
이를 허용하는 메커니즘이 **CORS**.

---

## 단순 요청(Simple Request)

Preflight(OPTIONS) 없이 바로 요청 가능.

조건:

* 메서드: `GET`, `POST`, `HEAD`
* Content-Type:

  * `application/x-www-form-urlencoded`
  * `multipart/form-data`
  * `text/plain`

---

## 예비 요청(Preflight Request)

조건을 벗어나면 브라우저는 먼저 OPTIONS 요청 전송:

```
OPTIONS /api/posts
   ↓
Origin: https://frontend.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Authorization
   ↓
서버에서 허용 응답
   ↓
PUT /api/posts 실제 요청
```

---

### 9. 실무에서 가장 자주 터지는 문제 & 디버깅 전략

### 1) 403 Forbidden

* 인증은 성공했으나 **인가 실패**

#### 체크 항목:

* URL 접근 권한 설정
* 역할(Role) 매칭 규칙
* CSRF 설정

---

### 2) CORS 에러

서버 오류가 발생했지만 CORS 헤더가 없어서
브라우저가 “CORS 문제”라고 오해할 수 있음.

➡️ **Security 레벨에서 CORS 설정을 반드시 함께 적용**해야 함

---

### 3) 로그인 성공 후 API 요청하면 갑자기 401

원인:

* 세션이 유지되지 않음
* JWT 토큰 누락
* 쿠키 옵션(`SameSite`, `Secure`, `Domain`) 문제

---

### 4) AuthenticationProvider 미등록

커스텀 인증 구현할 때 자주 발생.

---

### 5) PasswordEncoder 누락

인증은 되었으나 비밀번호 비교 단계에서 항상 실패 발생.


