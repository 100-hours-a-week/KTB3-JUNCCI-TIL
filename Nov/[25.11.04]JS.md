# 📚 JavaScript 핵심 개념 정리(익명함수/ 즉시실행함수/ 모듈 시스템)


---
# <mark> 익명 함수 (Anonymous Function) </mark>

## 정의

> 익명 함수(Anonymous Function)란
> 이름이 없는 함수로, **변수에 저장하거나**, **다른 함수의 인자로 전달**, **즉시 실행**하는 등의 용도로 사용되는 함수입니다.
>
> 한 번만 사용되거나 임시로 전달되는 함수 로직을 간결하게 표현할 때 주로 사용합니다.

---

## 특징 요약

| 항목            | 설명                                                 |
| ------------- | -------------------------------------------------- |
| **이름 없음**     | 함수 이름이 없어 직접 호출 불가 (보통 변수에 담거나 인자로 전달)             |
| **표현식으로 사용**  | 함수 선언문이 아닌 **함수 표현식(function expression)** 형태로 사용됨 |
| **즉시 실행 가능**  | 정의와 동시에 바로 실행 가능 (IIFE 패턴)                         |
| **클로저 생성 가능** | 함수 안에서 외부 변수를 기억할 수 있음                             |
| **간결한 코드**    | 간단한 로직을 간단히 표현할 때 유용                               |

---

## 기본 문법

```jsx
// 함수 이름이 없는 함수 표현식
const sayHello = function() {
  console.log("Hello!");
};

sayHello(); // Hello!
```

> 이름이 없기 때문에, 직접 호출하려면 **변수에 담거나 다른 함수에 전달**해야 합니다.

---

## 사용 이유 및 예시

### 1️⃣ 코드 간결성

```jsx
setTimeout(function() {
  console.log("3초 후 실행됩니다.");
}, 3000);

// 화살표 함수 표현
setTimeout(() => {
  console.log("3초 후 실행됩니다.");
}, 3000);
```

➡️ 이름이 필요 없는 “임시” 함수로 적합.

---

### 2️⃣ 임시 함수의 사용 (일회성 로직)

```jsx
document.querySelector("#btn").addEventListener("click", function() {
  console.log("버튼 클릭!");
});
```

➡️ 클릭 이벤트에만 필요한 로직이라 **별도 이름 불필요**.

---

### 3️⃣ 클로저 생성

```jsx
function makeCounter() {
  let count = 0;
  return function() { // 익명 함수
    return ++count;
  };
}

const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

➡️ `return function()` 구문으로 **익명 함수가 클로저를 형성**.

---

### 4️⃣ 콜백 함수로 전달

```jsx
const numbers = [1, 2, 3, 4];
const doubled = numbers.map(function(num) {
  return num * 2;
});
console.log(doubled); // [2, 4, 6, 8]
```

➡️ 한 번만 실행되는 콜백 로직을 간단히 표현.

---

### 5️⃣ 즉시 실행 함수 (IIFE)

```jsx
(function() {
  console.log("즉시 실행됨!");
})();
```

➡️ 정의와 동시에 실행되어 **초기화 코드**로 자주 사용.

---

## 💡 화살표 함수와 익명 함수

```jsx
// 기존 익명 함수
const add = function(a, b) {
  return a + b;
};

// 화살표 함수 (익명 함수의 축약형)
const addArrow = (a, b) => a + b;
```

> 둘 다 이름이 없지만, 화살표 함수는 `this`, `arguments`를 가지지 않습니다.

---

## 익명 함수를 사용하는 이유 요약

| 이유               | 설명           | 예시                                           |
| ---------------- | ------------ | -------------------------------------------- |
| **코드 간결성**       | 한 줄로 간단히 표현  | `setTimeout(function(){...},1000)`           |
| **임시 함수 사용**     | 재사용 불필요한 로직  | `addEventListener("click", function(){...})` |
| **클로저 생성**       | 상태 유지, 은닉 가능 | `return function(){count++}`                 |
| **콜백 / 이벤트 핸들러** | 함수 전달 시 유용   | `map(function(n){...})`                      |
| **즉시 실행 함수**     | 초기화용, 스코프 분리 | `(function(){...})()`                        |

---

## 주의할 점

| 주의사항        | 설명                                   |
| ----------- | ------------------------------------ |
| **디버깅 어려움** | 이름이 없으므로 에러 스택 추적 시 “anonymous”로 표시됨 |
| **재사용 불가**  | 이름이 없기 때문에 다른 곳에서 호출 불가              |
| **가독성 저하**  | 중첩 익명 함수가 많으면 코드 흐름 파악이 어려워짐         |

---

# <mark> 즉시 실행 함수 (IIFE: Immediately Invoked Function Expression) </mark>

## 정의

> **즉시 실행 함수(IIFE)**란
> 정의되자마자 바로 실행되는 함수로,
> **초기화 코드**나 **스코프 보호용 코드**에 자주 사용됩니다.

```jsx
(function() {
  console.log("즉시 실행됨!");
})();
```

---

## 왜 괄호로 감싸야 할까?

일반적인 함수 선언문은 바로 실행되지 않습니다.

```jsx
function test() {
  console.log("실행 안 됨");
}(); // SyntaxError
```

➡️ JS 엔진이 `function test(){}`를 “선언문”으로 인식하기 때문입니다.
**소괄호로 감싸면** 함수 표현식으로 인식되어 즉시 실행이 가능합니다.

---

## 기본 형태

```jsx
// 1️⃣ 일반 함수 형태
(function() {
  console.log("IIFE 실행");
})();

// 2️⃣ 화살표 함수 형태
(() => {
  console.log("Arrow IIFE 실행");
})();

// 3️⃣ 매개변수 전달
(function(name) {
  console.log(`Hello, ${name}!`);
})('Kim');
```

---

## IIFE의 핵심 개념 요약

| 개념            | 설명                      |
| ------------- | ----------------------- |
| **즉시 실행**     | 정의와 동시에 바로 호출됨          |
| **함수 표현식**    | 괄호로 감싸서 표현식으로 만듦        |
| **한 번만 실행**   | 재호출되지 않음 (초기화 용도)       |
| **독립 스코프 생성** | 전역 변수 오염 방지             |
| **클로저와 연계**   | 내부 변수를 외부에서 숨김 (은닉화 가능) |

---

## 사용 이유

### 1️⃣ 전역 변수 오염 방지

```jsx
(function() {
  const message = "IIFE 내부";
  console.log(message);
})();

console.log(typeof message); // "undefined"
```

➡️ 지역 스코프 생성으로 전역 네임스페이스 오염 방지

---

### 2️⃣ 초기 실행 / 페이지 로드 시 1회 실행

```jsx
(function() {
  console.log("페이지 초기화 중...");
  const user = { name: "Kim" };
  console.log(`Welcome, ${user.name}!`);
})();
```

---

### 3️⃣ 모듈 패턴 구현 (캡슐화)

```jsx
const Counter = (function() {
  let count = 0;

  function increase() {
    return ++count;
  }

  function getCount() {
    return count;
  }

  return { increase, getCount };
})();

console.log(Counter.increase()); // 1
console.log(Counter.getCount()); // 1
```

---

### 4️⃣ 이벤트 리스너 초기 설정

```jsx
(() => {
  document.querySelector('#btn').addEventListener('click', () => {
    console.log('버튼 클릭!');
  });
})();
```

---

### 5️⃣ 라이브러리 스코프 보호

```jsx
(function($) {
  $.fn.highlight = function() {
    this.css('background', 'yellow');
    return this;
  };
})(jQuery);
```

---

## 응용: 클로저와 결합

```jsx
const init = (function() {
  let initialized = false;

  return function() {
    if (!initialized) {
      console.log("초기 설정 실행");
      initialized = true;
    } else {
      console.log("이미 초기화됨");
    }
  };
})();

init(); // "초기 설정 실행"
init(); // "이미 초기화됨"
```

---

## 다양한 IIFE 패턴들

```jsx
(function() { /* 코드 */ })();
(() => { /* 코드 */ })();
((msg) => { console.log(msg); })("Hello!");
const result = (function(a, b) { return a + b; })(3, 4);
```

---

## 장단점 요약

| 구분     | 설명                                               |
| ------ | ------------------------------------------------ |
| **장점** | 전역 변수 오염 방지, 초기화 코드에 적합, 클로저로 은닉 가능, 모듈 패턴 구현 가능 |
| **단점** | 재사용 불가, 디버깅 어려움, 가독성 저하 (남용 시)                   |

---

# <mark> 모듈 시스템 (Module System) </mark>

## 정의

| 모듈 | 재사용 가능한 코드 조각 |
| -- | ------------- |

모듈(Module)은 **프로그램을 구성하는 독립적인 코드 조각**으로,
**관련된 함수, 변수, 클래스 등을 하나의 파일로 묶어 관리**하는 단위입니다.
자신만의 **독립적인 스코프**를 가집니다.

---

## 함수 vs 모듈 vs 컴포넌트

| 구분              | 설명                                     |
| --------------- | -------------------------------------- |
| 함수(Function)    | 특정 작업을 수행하는 코드의 묶음 (입력 → 처리 → 출력)      |
| 모듈(Module)      | 관련된 함수, 변수, 클래스 등을 파일 단위로 묶은 독립된 코드 단위 |
| 컴포넌트(Component) | UI를 구성하는 단위 (상태 + 렌더링 로직)              |

> **함수**는 로직의 최소 단위,
> **모듈**은 코드 구조화 단위,
> **컴포넌트**는 UI 표현 단위입니다.

---

## 사용 이유

1. 코드 재사용성 증가
2. 유지보수 용이성
3. 네임스페이스 충돌 방지
4. 가독성과 테스트 용이성 향상

---

## 사용 방법

자바스크립트의 모듈 시스템은 크게 두 가지입니다.

### CommonJS (CJS)

* Node.js 환경 전용
* **동기적 로딩** (`require`)
* 백엔드 중심

```jsx
// math.js
function add(a, b) { return a + b; }
function subtract(a, b) { return a - b; }
module.exports = { add, subtract };

// main.js
const math = require('./math.js');
console.log(math.add(10, 5)); // 15
```

---

### ES Module (ESM)

* ES6에서 도입된 **표준 모듈 시스템**
* **정적 import/export**
* 프론트엔드 표준
* Node.js 12+ 공식 지원

#### Named Export / Import

```jsx
// math.js
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; }
```

```jsx
import { add, subtract } from './math.js';
console.log(add(10, 5)); // 15
```

#### Default Export / Import

```jsx
// math.js
export default {
  add(a, b) { return a + b; },
  subtract(a, b) { return a - b; }
};
```

```jsx
import math from './math.js';
console.log(math.add(10, 5)); // 15
```

---

## Tree-shaking (트리 셰이킹)

> 사용되지 않는 코드를 제거하는 최적화 기법

```jsx
// math.js
export function add(a, b) { return a + b; }
export function subtract(a, b) { return a - b; } // 사용 X
```

```jsx
// main.js
import { add } from './math.js';
console.log(add(10, 5)); // 15
```

➡️ `subtract()`는 사용되지 않으므로 번들에서 제거됨.

---

## ESM 주의사항

1. **`__dirname` / `__filename` 미지원**
   → `import.meta.url` 기반으로 대체
2. **CJS와 호환성 주의** (`default` 속성 감싸짐)
3. **비동기 로딩 특성**
   → `await import()` 사용 필요

---

