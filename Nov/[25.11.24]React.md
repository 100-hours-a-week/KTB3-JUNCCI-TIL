# 📚 React 핵심 개념 정리(Basic)

---
# React 기초 정리

## **React란?**

- **UI = f(state)** 개념을 실제로 구현하게 해주는 **선언적 UI 라이브러리**
- 상태(state)가 바뀌면 React가 UI를 알아서 업데이트한다.
- DOM을 직접 조작하지 않아도 되도록 추상화된 계층(Virtual DOM)을 제공한다.
- UI를 **컴포넌트 단위**로 쪼개서 재사용성과 유지보수성을 높인다.

---

## **State(상태)란?**

- UI에 영향을 주는 모든 데이터.
- 예: 장바구니 개수, 입력 중인 검색어, 모달 열림 여부 등.
- **UI = f(state)** → UI는 상태를 받아 생성되는 "함수의 출력물"이다.
- 상태가 바뀌면 React는 컴포넌트를 다시 렌더링해 새로운 UI를 만든다.

---

## **선언적 UI vs 명령형 UI**

**명령형 방식(Vanilla JS)**

- “무엇을 어떻게 바꿀지(document.querySelector, innerHTML 등)”를 직접 지시.

**선언적 방식(React)**

- “상태가 이럴 때 화면은 이렇게 생겼다”만 정의.
- 상태 변경(setState)만 하면 React가 어떤 DOM을 업데이트해야 하는지 알아서 처리.

---

## **컴포넌트(Component)란?**

- “입력(props)을 받아 UI를 반환하는 함수”
- UI 구조 + 로직 + 이벤트를 하나의 단위로 묶은 것(캡슐화)
- 장점:
    - **캡슐화** (내부 구현 감춘다)
    - **재사용성**
    - **조합(Composition)**: 컴포넌트를 합쳐 더 큰 컴포넌트를 만든다
    - **단방향 데이터 흐름** 기반의 예측 가능한 구조

---

## **단방향 데이터 흐름(One-Way Data Flow)**

- 데이터는 **부모 → 자식(props)** 으로만 흐름.
- 자식은 부모의 상태를 직접 변경할 수 없다.
- 변경이 필요하면 **부모가 전달한 함수**를 호출해 요청.
- 이유: 앱이 커져도 “어디에서 데이터가 변경됐는지” 추적이 쉬워짐.

---

## **JSX란?**

- JavaScript 내부에서 HTML 구조를 기술할 수 있게 해주는 문법 확장.
- 브라우저가 이해하지 못하므로 빌드 과정에서 **React.createElement** 형태로 변환됨.
- JSX는 HTML이 아니라 **결국 JS 값(element 객체)** 이다.

---

## **DOM(Document Object Model)이란?**

- 브라우저가 HTML 텍스트를 파싱해 만든 “트리 형태의 객체 구조”
- JavaScript로 조작할 수 있는 인터페이스(API)
- DOM 수정은 **Reflow / Repaint**를 일으켜 비용이 매우 비싸다.

---

## **Virtual DOM(VDOM)이란?**

- 실제 DOM을 추상화한 **메모리 상의 가상 DOM 객체**
- UI = f(state) 로 “전체를 다시 그린다”고 생각하고 코드 작성해도,
    
    React는 **변경된 부분만 골라 실제 DOM에 반영**한다.
    
- 목적:
    - DOM 조작 비용 절감
    - 선언적 UI 구현
    - Batching(일괄 처리)로 성능 최적화

---

## **Diffing 알고리즘**

- 이전 VDOM과 새로운 VDOM을 비교해 최소 변경사항만 실제 DOM에 반영하는 과정.
- React는 O(n³)가 아닌 O(n) 수준의 heuristic 기반 비교 사용.
- 두 가지 핵심 규칙:
    1. **엘리먼트 타입이 다르면** 하위 트리 전부 갈아끼움
    2. **key로 자식 리스트의 안정성**을 추적

---

## **Key의 역할**

- 리스트 아이템의 “정체성”을 React가 파악하기 위한 식별자.
- key가 불안정하면(예: index 사용) 입력값 섞임, 버그, 성능 문제 발생.
- 아이템 고유 ID 같은 안정된 값 사용해야 한다.

---

## **불변성(Immutable State)의 이유**

- React는 상태 변경 여부를 **얕은 비교(참조 비교)** 로 판단한다.
- 기존 객체/배열을 직접 수정하면 참조값이 동일해 렌더링이 일어나지 않는다.
- 항상 “새로운 객체/배열”을 만들어 setState 해야 한다.

---

## **React 18 Concurrent Rendering**

- Fiber architecture 기반.
- 렌더링 작업을 조각내서 우선순위 기반으로 수행.
- 사용자 입력처럼 중요 이벤트는 즉시 반응하고,
    
    무거운 렌더링은 백그라운드에서 처리.
    
- startTransition 등이 대표적인 기능.

---

## **Vite란?**

- 매우 빠른 개발 서버와 빌드 환경 제공하는 도구.
- 이유:
    - esbuild(Go로 작성)를 활용한 빠른 트랜스파일링
- 개발 속도 체감이 뛰어남.

---

## **VDOM은 React만 쓰는가?**

- Vue: 비슷한 VDOM, 하지만 템플릿을 활용해 정적/동적 부분을 컴파일 단계에서 최적화.
- Svelte: “VDOM이 오버헤드”라 하며 VDOM을 사용하지 않음. 컴파일 타임에 실제 DOM 조작 코드를 미리 생성.
- Angular: Incremental DOM 방식으로 직접 DOM 업데이트하는 명령형 코드로 컴파일.

---
