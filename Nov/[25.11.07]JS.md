# 📚 JS 핵심 개념 정리(Promise)

---
# <mark> Promise </mark>

> 비동기 작업의 최종 완료 또는 실패를 나타내는 객체
> 

Promise는 **아직 완료되지 않은 작업**을 “결과를 약속한 상자”처럼 다루는 방식입니다.

미래에 어떤 값이 생길지 모르지만, **성공(fulfilled)** 하든 **실패(rejected)** 하든 **한 번 결정되면 바뀌지 않습니다.**

---

## Promise의 3가지 상태 (Three States)

| 상태 | 설명 | 다음 상태로의 전이 |
| --- | --- | --- |
| **pending (대기)** | 초기 상태. 아직 결과가 정해지지 않음 | → fulfilled 또는 rejected 로 전이 |
| **fulfilled (이행)** | 작업이 성공적으로 완료되어 `resolve()`가 호출됨 | 더 이상 상태 변화 없음 |
| **rejected (거부)** | 작업이 실패하거나 에러가 발생하여 `reject()`가 호출됨 | 더 이상 상태 변화 없음 |

```jsx
const p = new Promise((resolve, reject) => {
  // 1. 처음엔 pending
  setTimeout(() => {
    resolve("성공!"); // 2. fulfilled
    // reject("실패!"); // 2. rejected
  }, 1000);
});

```

한 번 `resolve()` 또는 `reject()`가 호출되면 상태는 **결정(settled)** 되며, 다시 변경되지 않습니다.

---

## 상태 전이 (State Transition)

```
           ┌─────────────┐
           │   pending   │
           └──────┬──────┘
                  │
     ┌────────────┴────────────┐
     ▼                         ▼
┌────────────┐          ┌────────────┐
│ fulfilled  │          │  rejected  │
└────────────┘          └────────────┘

```

- Promise는 **오직 한 번**만 상태를 변경할 수 있습니다.
- 상태가 `fulfilled` 또는 `rejected` 로 전이되면 **settled(정착)** 되었다고 합니다.

---

## 실행 흐름

Promise는 생성 즉시 **executor 함수**를 동기적으로 실행합니다.

즉, 다음 코드를 보면 setTimeout이 비동기지만, Promise 자체는 즉시 실행돼요.

```jsx
console.log("1");

const p = new Promise((resolve, reject) => { //Promise는 객체 이기 때문에 new로 생성
  console.log("2");
  setTimeout(() => resolve("3"), 1000);
});

p.then(result => console.log(result));
console.log("4");

// 실행 순서: 1 → 2 → 4 → (1초 뒤) 3

```

---

## 상태에 따른 후속 처리

Promise는 단순히 상태만 갖는 게 아니라, 상태 변화에 따라 **후속 동작을 연결**할 수 있습니다.

이를 위해 `then`, `catch`, `finally` 메서드를 사용합니다.

```jsx
p
  .then(result => console.log("성공:", result))   // fulfilled 시 실행
  .catch(error => console.error("실패:", error)) // rejected 시 실행
  .finally(() => console.log("작업 완료"));       // 항상 실행

```

---

## 내부 메커니즘 요약

| 동작 | 설명 |
| --- | --- |
| `resolve(value)` | Promise를 성공 상태(`fulfilled`)로 바꾸고 value 전달 |
| `reject(error)` | Promise를 실패 상태(`rejected`)로 바꾸고 error 전달 |
| `.then(onFulfilled, onRejected)` | 상태 변화에 따른 콜백 등록 |
| `.catch(onRejected)` | 실패 시 실행할 콜백 등록 |
| `.finally(onFinally)` | 성공·실패 상관없이 마지막에 실행할 콜백 등록 |

---

## 비동기 흐름 제어

Promise의 강점은 **비동기 작업을 순서대로 제어**할 수 있다는 점이에요.

```jsx
new Promise(resolve => setTimeout(() => resolve(1), 1000))
  .then(num => {
    console.log(num); // 1
    return num + 1;
  })
  .then(num => {
    console.log(num); // 2
    return num + 1;
  })
  .then(num => {
    console.log(num); // 3
  });

```

- 각 `then`은 이전 `then`의 반환값을 이어받음
- `then` 체이닝은 **새로운 Promise**를 반환
- 이런 흐름 제어 덕분에 콜백 지옥을 피할 수 있음

---

## 상태와 에러의 전파

Promise 체인에서 에러가 발생하면 **자동으로 다음 `catch`로 전달**됩니다.

```jsx
Promise.resolve("시작")
  .then(() => {
    throw new Error("문제 발생!");
  })
  .catch(err => {
    console.error(err.message); // 문제 발생!
  });

```

또한, `catch` 안에서 값을 반환하면 체인이 복구됩니다.

```jsx
Promise.reject("에러")
  .catch(err => {
    console.log("복구 시도");
    return "복구됨";
  })
  .then(result => console.log(result)); // "복구됨"

```

---

## Promise의 정리 요약

| 구분 | 설명 |
| --- | --- |
| **정의** | 비동기 작업의 결과를 나타내는 객체 |
| **상태** | pending → fulfilled / rejected |
| **전이** | 한 번 정해지면 불변 |
| **핵심 메서드** | then / catch / finally |
| **장점** | 콜백 지옥 방지, 에러 흐름 통합, 코드 가독성 향상 |
| **단점** | 체이닝이 길어지면 여전히 복잡할 수 있음 (→ Async/Await로 해결) |

---
